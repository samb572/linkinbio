<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clear Edge Sports - NFL Model</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: #111a29;
            color: white;
            padding: 20px;
            line-height: 1.6;
            position: relative;
            overflow-x: hidden;
            min-height: 100vh;
        }
        
        /* Enhanced animated background - matching business site */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                linear-gradient(135deg, #111a29 0%, #1a2332 30%, #0f1419 70%, #111a29 100%);
            z-index: -2;
        }

        body::after {
            content: '';
            position: fixed;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: 
                conic-gradient(from 0deg at 25% 25%, transparent 0deg, rgba(59, 130, 246, 0.08) 45deg, transparent 90deg),
                conic-gradient(from 180deg at 75% 75%, transparent 0deg, rgba(255, 215, 0, 0.08) 45deg, transparent 90deg),
                conic-gradient(from 90deg at 50% 50%, transparent 0deg, rgba(139, 69, 19, 0.05) 30deg, transparent 60deg);
            animation: rotate 25s linear infinite;
            z-index: -1;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .password-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        
        .password-container {
            background: rgba(255, 255, 255, 0.03);
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 20px;
            padding: 50px;
            text-align: center;
            max-width: 450px;
            width: 100%;
            backdrop-filter: blur(15px);
            position: relative;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.3);
        }

        .password-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, #FFD700, transparent);
            animation: shimmer 3s ease-in-out infinite alternate;
        }

        @keyframes shimmer {
            0% { opacity: 0.3; }
            100% { opacity: 1; }
        }
        
        .password-title {
            font-size: 28px;
            font-weight: 900;
            color: #FFD700;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 3px;
            text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.5);
        }

        .password-subtitle {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 30px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .password-input {
            width: 100%;
            padding: 18px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 12px;
            color: white;
            font-size: 18px;
            text-align: center;
            letter-spacing: 2px;
            transition: all 0.3s ease;
            margin: 20px 0;
            outline: none;
            font-weight: 600;
        }

        .password-input:focus {
            border-color: #FFD700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
            transform: scale(1.02);
        }

        .password-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
            font-weight: 400;
        }
        
        .password-submit {
            width: 100%;
            padding: 15px 40px;
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            color: #111a29;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 800;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 5px 20px rgba(255, 215, 0, 0.3);
        }

        .password-submit:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 8px 25px rgba(255, 215, 0, 0.5);
        }
        
        .password-error {
            color: #ff4444;
            font-size: 14px;
            margin-top: 15px;
            display: none;
            font-weight: 600;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3);
        }
        
        .main-content {
            display: none;
            position: relative;
            z-index: 1;
        }
        
        .container {
            max-width: 1000px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            color: white;
            margin-bottom: 40px;
            font-size: 3rem;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 3px;
            text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.5);
        }

        .model-subtitle {
            text-align: center;
            color: #FFD700;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: 700;
            margin-bottom: 40px;
        }

        .calculation-mode {
            display: flex;
            justify-content: center;
            margin-bottom: 30px;
        }

        .mode-btn {
            padding: 12px 24px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 12px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 0 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .mode-btn.active {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            color: #111a29;
            border-color: #FFD700;
        }

        .mode-btn:hover {
            border-color: #FFD700;
            transform: translateY(-2px);
        }
        
        .input-card {
            background: rgba(255, 255, 255, 0.03);
            border: 2px solid rgba(255, 215, 0, 0.15);
            border-radius: 20px;
            padding: 30px;
            backdrop-filter: blur(15px);
            position: relative;
            overflow: hidden;
            margin-bottom: 30px;
        }

        .input-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, #FFD700, transparent);
            animation: shimmer 3s ease-in-out infinite alternate;
        }

        .bulk-section {
            display: none;
        }

        .bulk-filters {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .input-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            color: #FFD700;
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        input[type="text"], input[type="number"], select {
            width: 100%;
            padding: 12px 15px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 8px;
            color: white;
            font-size: 16px;
            transition: all 0.3s ease;
            outline: none;
        }
        
        input:focus, select:focus {
            border-color: #FFD700;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.2);
            background: rgba(255, 255, 255, 0.15);
        }

        input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }
        
        .calculate-btn {
            width: 100%;
            padding: 18px;
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            color: #111a29;
            border: none;
            border-radius: 12px;
            font-size: 18px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 20px;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 5px 20px rgba(255, 215, 0, 0.3);
        }
        
        .calculate-btn:hover {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 8px 25px rgba(255, 215, 0, 0.5);
        }
        
        .calculate-btn:active {
            transform: translateY(0);
        }

        .bulk-results {
            background: rgba(255, 255, 255, 0.03);
            border: 2px solid rgba(255, 215, 0, 0.15);
            border-radius: 20px;
            padding: 30px;
            backdrop-filter: blur(15px);
            position: relative;
            overflow: hidden;
            margin-top: 30px;
        }

        .bulk-results::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, #FFD700, transparent);
            animation: shimmer 3s ease-in-out infinite alternate;
        }

        .bulk-results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid rgba(255, 215, 0, 0.3);
        }

        .results-count {
            color: #FFD700;
            font-size: 16px;
            font-weight: 600;
        }

        .export-btn {
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.1);
            color: #FFD700;
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 8px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }

        .export-btn:hover {
            background: rgba(255, 215, 0, 0.1);
            border-color: #FFD700;
        }

        .bulk-result-item {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 215, 0, 0.2);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
            transition: all 0.3s ease;
        }

        .bulk-result-item:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 215, 0, 0.4);
            transform: translateY(-2px);
        }

        .result-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .player-info {
            font-size: 16px;
            font-weight: 700;
            color: white;
        }

        .matchup-info {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.7);
        }

        .projection-score {
            font-size: 20px;
            font-weight: 800;
            padding: 5px 12px;
            border-radius: 8px;
            background: rgba(255, 215, 0, 0.2);
            color: #FFD700;
            border: 1px solid rgba(255, 215, 0, 0.3);
        }

        .result-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin-top: 10px;
            font-size: 12px;
        }

        .detail-item {
            text-align: center;
        }

        .detail-label {
            color: #FFD700;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 3px;
        }

        .detail-value {
            color: rgba(255, 255, 255, 0.9);
            font-weight: 600;
        }
        
        .results {
            background: rgba(255, 255, 255, 0.03);
            border: 2px solid rgba(255, 215, 0, 0.15);
            border-radius: 20px;
            padding: 30px;
            backdrop-filter: blur(15px);
            position: relative;
            overflow: hidden;
        }

        .results::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, #FFD700, transparent);
            animation: shimmer 3s ease-in-out infinite alternate;
        }
        
        .result-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 0;
            border-bottom: 1px solid rgba(255, 215, 0, 0.2);
        }
        
        .result-item:last-child {
            border-bottom: none;
        }
        
        .result-label {
            color: #FFD700;
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .result-value {
            font-size: 18px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.9);
        }
        
        .final-score {
            font-size: 32px !important;
            color: #FFD700 !important;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
        }
        
        .score-interpretation {
            margin-top: 20px;
            padding: 15px;
            border-radius: 12px;
            text-align: center;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .score-high {
            background: rgba(34, 197, 94, 0.1);
            border: 2px solid rgba(34, 197, 94, 0.3);
            color: #22c55e;
        }
        
        .score-medium {
            background: rgba(255, 215, 0, 0.1);
            border: 2px solid rgba(255, 215, 0, 0.3);
            color: #FFD700;
        }
        
        .score-low {
            background: rgba(239, 68, 68, 0.1);
            border: 2px solid rgba(239, 68, 68, 0.3);
            color: #ef4444;
        }
        
        .info-text {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
            margin-top: 5px;
            font-style: italic;
        }

        .autocomplete-container {
            position: relative;
        }

        .autocomplete-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: rgba(17, 26, 41, 0.95);
            backdrop-filter: blur(15px);
            border: 2px solid rgba(255, 215, 0, 0.5);
            border-top: none;
            border-radius: 0 0 8px 8px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5);
        }

        .autocomplete-suggestion {
            padding: 12px 15px;
            color: rgba(255, 255, 255, 0.9);
            cursor: pointer;
            transition: all 0.2s ease;
            border-bottom: 1px solid rgba(255, 215, 0, 0.1);
        }

        .autocomplete-suggestion:hover,
        .autocomplete-suggestion.selected {
            background: rgba(255, 215, 0, 0.2);
            color: #FFD700;
        }

        .autocomplete-suggestion:last-child {
            border-bottom: none;
        }

        .autocomplete-suggestions::-webkit-scrollbar {
            width: 6px;
        }

        .autocomplete-suggestions::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
        }

        .autocomplete-suggestions::-webkit-scrollbar-thumb {
            background: rgba(255, 215, 0, 0.5);
            border-radius: 3px;
        }
        
        .game-context-scale {
            margin-top: 10px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
        }
        
        .loading {
            text-align: center;
            color: #FFD700;
            padding: 20px;
            font-weight: 600;
        }
        
        .error {
            text-align: center;
            color: #ef4444;
            padding: 20px;
            font-weight: 600;
        }
        
        .coverage-info {
            background: rgba(255, 215, 0, 0.1);
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .coverage-info h4 {
            color: #FFD700;
            margin-bottom: 5px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .coverage-info p {
            color: rgba(255, 255, 255, 0.8);
            font-weight: 500;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #FFD700, #FFA500);
            width: 0%;
            transition: width 0.3s ease;
        }

        .progress-text {
            text-align: center;
            color: #FFD700;
            font-size: 14px;
            font-weight: 600;
            margin-top: 5px;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            h1 {
                font-size: 2.5rem;
            }

            .password-container {
                padding: 30px 20px;
            }

            .password-title {
                font-size: 24px;
            }
            
            .input-card, .results, .bulk-results {
                padding: 20px;
            }

            .calculation-mode {
                flex-direction: column;
                align-items: center;
            }

            .mode-btn {
                margin: 5px 0;
                width: 200px;
            }

            .bulk-filters {
                grid-template-columns: 1fr;
            }

            .result-details {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="password-overlay" id="passwordOverlay">
        <div class="password-container">
            <h2 class="password-title">Clear Edge</h2>
            <p class="password-subtitle">NFL Model Access</p>
            <input type="password" class="password-input" id="passwordInput" placeholder="Enter Password" autocomplete="off">
            <button class="password-submit" id="passwordSubmit">ACCESS MODEL</button>
            <div class="password-error" id="passwordError">Incorrect password. Please try again.</div>
        </div>
    </div>

    <div class="main-content" id="mainContent">
        <div class="container">
            <h1>NFL Model</h1>
            <p class="model-subtitle">Advanced Analytics & Predictions</p>
            
            <div class="calculation-mode">
                <button class="mode-btn active" id="singleModeBtn">Single Player</button>
                <button class="mode-btn" id="bulkModeBtn">Bulk Analysis</button>
            </div>

            <div class="input-card" id="singleSection">
                <div class="input-group">
                    <label for="playerName">Player Name</label>
                    <div class="autocomplete-container">
                        <input type="text" id="playerName" placeholder="e.g., Ja'Marr Chase" autocomplete="off">
                        <div class="autocomplete-suggestions" id="playerSuggestions"></div>
                    </div>
                </div>
                
                <div class="input-group">
                    <label for="opponentTeam">Opponent Team</label>
                    <div class="autocomplete-container">
                        <input type="text" id="opponentTeam" placeholder="e.g., Jacksonville Jaguars or JAX" autocomplete="off">
                        <div class="autocomplete-suggestions" id="teamSuggestions"></div>
                    </div>
                </div>
                
                <div class="input-group">
                    <label for="gameFlow">Expected Game Flow</label>
                    <select id="gameFlow">
                        <option value="3">Neutral (Even matchup)</option>
                        <option value="1">Heavy Favorite (14+ point favorite)</option>
                        <option value="2">Slight Favorite (7-13 point favorite)</option>
                        <option value="4">Slight Underdog (7-13 point underdog)</option>
                        <option value="5">Heavy Underdog (14+ point underdog)</option>
                    </select>
                    <div class="info-text">How the game script is expected to play out</div>
                </div>
                
                <div class="input-group">
                    <label for="routesPerGame">Routes Per Game</label>
                    <input type="number" id="routesPerGame" placeholder="e.g., 35" min="0" max="60" value="35">
                    <div class="info-text">Average routes run per game by the player</div>
                </div>
                
                <div class="input-group">
                    <label for="bettingLine">Betting Line (Receptions)</label>
                    <input type="number" id="bettingLine" placeholder="e.g., 5.5" step="0.5" min="0" max="15">
                    <div class="info-text">Over/Under line for player receptions</div>
                </div>
                
                <button class="calculate-btn" id="calculateBtn">Calculate Reception Projection</button>
            </div>

            <div class="input-card bulk-section" id="bulkSection">
                <div class="bulk-filters">
                    <div class="input-group">
                        <label for="bulkWeek">Week</label>
                        <select id="bulkWeek">
                            <option value="">All Weeks</option>
                            <option value="1">Week 1</option>
                            <option value="2">Week 2</option>
                            <option value="3">Week 3</option>
                            <option value="4">Week 4</option>
                            <option value="5">Week 5</option>
                            <option value="6">Week 6</option>
                            <option value="7">Week 7</option>
                            <option value="8">Week 8</option>
                            <option value="9">Week 9</option>
                            <option value="10">Week 10</option>
                            <option value="11">Week 11</option>
                            <option value="12">Week 12</option>
                            <option value="13">Week 13</option>
                            <option value="14">Week 14</option>
                            <option value="15">Week 15</option>
                            <option value="16">Week 16</option>
                            <option value="17">Week 17</option>
                            <option value="18">Week 18</option>
                        </select>
                    </div>
                    
                    <div class="input-group">
                        <label for="bulkTeam">Team</label>
                        <select id="bulkTeam">
                            <option value="">All Teams</option>
                        </select>
                    </div>
                    
                    <div class="input-group">
                        <label for="bulkGameFlow">Game Flow</label>
                        <select id="bulkGameFlow">
                            <option value="3">Neutral (Even matchup)</option>
                            <option value="1">Heavy Favorite (14+ point favorite)</option>
                            <option value="2">Slight Favorite (7-13 point favorite)</option>
                            <option value="4">Slight Underdog (7-13 point underdog)</option>
                            <option value="5">Heavy Underdog (14+ point underdog)</option>
                        </select>
                    </div>
                </div>
                
                <button class="calculate-btn" id="bulkCalculateBtn">Run Bulk Analysis</button>
                
                <div id="bulkProgress" style="display: none;">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                    <div class="progress-text" id="progressText">Analyzing players...</div>
                </div>
            </div>
            
            <div id="loadingDiv" class="loading" style="display: none;">
                Calculating projection...
            </div>
            
            <div id="errorDiv" class="error" style="display: none;"></div>
            
            <div class="results" id="results" style="display: none;">
                <div id="coverageInfo" class="coverage-info"></div>
                
                <div class="result-item">
                    <span class="result-label">Player</span>
                    <span class="result-value" id="playerDisplay">-</span>
                </div>
                <div class="result-item">
                    <span class="result-label">vs Defense</span>
                    <span class="result-value" id="defenseDisplay">-</span>
                </div>
                <div class="result-item">
                    <span class="result-label">Target Share</span>
                    <span class="result-value" id="targetShare">-</span>
                </div>
                <div class="result-item">
                    <span class="result-label">Weighted TPRR</span>
                    <span class="result-value" id="tprrDisplay">-</span>
                </div>
                <div class="result-item">
                    <span class="result-label">Separation Score</span>
                    <span class="result-value" id="sepScoreDisplay">-</span>
                </div>
                <div class="result-item" style="margin-top: 10px; padding-top: 20px; border-top: 2px solid #FFD700;">
                    <span class="result-label" style="font-size: 18px;">Expected Receptions</span>
                    <span class="result-value" id="expectedReceptions" style="font-size: 24px;">-</span>
                </div>
                <div class="result-item">
                    <span class="result-label" style="font-size: 18px;">Edge Score</span>
                    <span class="result-value final-score" id="finalScore">-</span>
                </div>
                <div class="score-interpretation" id="interpretation"></div>
            </div>

            <div class="bulk-results" id="bulkResults" style="display: none;">
                <div class="bulk-results-header">
                    <div class="results-count" id="resultsCount">0 players analyzed</div>
                    <button class="export-btn" id="exportBtn">Export CSV</button>
                </div>
                <div id="bulkResultsList"></div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.3/dist/umd/supabase.min.js"></script>

    <script>
        // Initialize Supabase client immediately when the script loads
        // Make sure these are truly const and not re-assigned later
        const SUPABASE_URL = 'https://pyjtwdgapmbdgtpflzan.supabase.co';
        const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InB5anR3ZGdhcG1iZGd0cGZsemFuIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTExNTEzNTgsImV4cCI6MjA2NjcyNzM1OH0._Bt_XomEPAYRqC6zNgkNDwq66XFlpMoPbNMB6Eb4USo';
        const SEASON = 2024;
        const BULK_SEASON = 2025; // For bulk analysis using weekly_matchups

        let supabaseClient = null; // Declared here, initialized in window.load

        let playerList = [];
        let selectedIndex = -1;
        let bulkResults = [];

        window.addEventListener('load', function() {
            try {
                // Check if window.supabase exists and create client
                if (typeof window.supabase !== 'undefined' && window.supabase.createClient) {
                    supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
                    console.log('Supabase client initialized successfully via window.supabase');
                } else {
                    console.error('Supabase library not loaded or createClient is not available. Check the script tag and network.');
                    showError('Failed to load Supabase. Please check your browser console for details.');
                    return; // Stop further execution if Supabase client cannot be initialized
                }
            } catch (error) {
                console.error('Error during Supabase client creation:', error);
                showError('Error initializing Supabase client: ' + error.message + '. Ensure URL/Key are correct.');
                return; // Stop further execution if initialization fails
            }
            
            setupPasswordHandling();
            setupModeToggle();
            setupAutocomplete(); // This will call loadPlayerNames, which needs supabaseClient
            setupBulkTeams();
            document.getElementById('calculateBtn').addEventListener('click', calculateProjection);
            document.getElementById('bulkCalculateBtn').addEventListener('click', runBulkAnalysis);
            document.getElementById('exportBtn').addEventListener('click', exportResults);
        });

        function setupPasswordHandling() {
            const passwordOverlay = document.getElementById('passwordOverlay');
            const mainContent = document.getElementById('mainContent');
            const passwordInput = document.getElementById('passwordInput');
            const passwordSubmitBtn = document.getElementById('passwordSubmit');
            const passwordError = document.getElementById('passwordError');

            function checkPassword() {
                const correctPassword = 'KT81qd2023#';
                if (passwordInput.value === correctPassword) {
                    passwordOverlay.style.display = 'none';
                    mainContent.style.display = 'block';
                } else {
                    passwordError.style.display = 'block';
                    passwordInput.value = '';
                    setTimeout(() => {
                        passwordError.style.display = 'none';
                    }, 3000);
                }
            }

            passwordSubmitBtn.addEventListener('click', checkPassword);
            passwordInput.addEventListener('keypress', function(event) {
                if (event.key === 'Enter') {
                    checkPassword();
                }
            });

            passwordInput.focus();
        }

        function setupModeToggle() {
            const singleModeBtn = document.getElementById('singleModeBtn');
            const bulkModeBtn = document.getElementById('bulkModeBtn');
            const singleSection = document.getElementById('singleSection');
            const bulkSection = document.getElementById('bulkSection');
            const results = document.getElementById('results');
            const bulkResults = document.getElementById('bulkResults');

            singleModeBtn.addEventListener('click', () => {
                singleModeBtn.classList.add('active');
                bulkModeBtn.classList.remove('active');
                singleSection.style.display = 'block';
                bulkSection.style.display = 'none';
                results.style.display = 'none';
                bulkResults.style.display = 'none';
                hideError(); // Clear any previous errors
            });

            bulkModeBtn.addEventListener('click', () => {
                bulkModeBtn.classList.add('active');
                singleModeBtn.classList.remove('active');
                singleSection.style.display = 'none';
                bulkSection.style.display = 'block';
                results.style.display = 'none';
                bulkResults.style.display = 'none';
                hideError(); // Clear any previous errors
            });
        }

        async function setupBulkTeams() {
            const bulkTeamSelect = document.getElementById('bulkTeam');
            const teams = [
                'Arizona Cardinals', 'Atlanta Falcons', 'Baltimore Ravens', 'Buffalo Bills',
                'Carolina Panthers', 'Chicago Bears', 'Cincinnati Bengals', 'Cleveland Browns',
                'Dallas Cowboys', 'Denver Broncos', 'Detroit Lions', 'Green Bay Packers',
                'Houston Texans', 'Indianapolis Colts', 'Jacksonville Jaguars', 'Kansas City Chiefs',
                'Las Vegas Raiders', 'Los Angeles Chargers', 'Los Angeles Rams', 'Miami Dolphins',
                'Minnesota Vikings', 'New England Patriots', 'New Orleans Saints', 'New York Giants',
                'New York Jets', 'Philadelphia Eagles', 'Pittsburgh Steelers', 'San Francisco 49ers',
                'Seattle Seahawks', 'Tampa Bay Buccaneers', 'Tennessee Titans', 'Washington Commanders'
            ];

            teams.forEach(team => {
                const option = document.createElement('option');
                option.value = team;
                option.textContent = team;
                bulkTeamSelect.appendChild(option);
            });
        }

        async function runBulkAnalysis() {
            const week = document.getElementById('bulkWeek').value;
            const team = document.getElementById('bulkTeam').value;
            const gameFlow = parseInt(document.getElementById('bulkGameFlow').value);

            showBulkLoading(true);
            hideBulkResults();
            hideError();
            bulkResults = [];

            // CRITICAL CHECK: Ensure supabaseClient is ready
            if (!supabaseClient) {
                showError('Supabase client not initialized. Cannot perform bulk analysis. Please refresh the page.');
                showBulkLoading(false);
                return; // Stop execution if client isn't ready
            }

            try {
                console.log('Starting bulk analysis...');
                
                // Robust test call to ensure the client is functional and the key is accepted
                const { error: testError } = await supabaseClient
                    .from('player_cover_stats') // Use a table you know exists
                    .select('player_name')     // Select a valid column from that table
                    .limit(1);

                if (testError) {
                    console.error('Supabase initial query failed:', testError);
                    throw new Error(`Supabase connection failed: ${testError.message}. Double-check your API key and table permissions.`);
                }
                console.log('Supabase client is making requests successfully (initial test passed).');
                updateProgress(5, `Connection verified. Fetching matchups...`);

                // Get matchups based on filters
                let matchupsQuery = supabaseClient
                    .from('weekly_matchups')
                    .select('*')
                    .eq('season', BULK_SEASON);

                if (week) {
                    matchupsQuery = matchupsQuery.eq('week', parseInt(week));
                }

                console.log('Fetching matchups...');
                const { data: matchups, error: matchupError } = await matchupsQuery;

                if (matchupError) {
                    console.error('Matchups error:', matchupError);
                    throw new Error('Error fetching matchups: ' + matchupError.message);
                }

                if (!matchups || matchups.length === 0) {
                    console.warn('No matchups found for the selected criteria.');
                    showError('No matchups found for the selected criteria. Please adjust filters.');
                    showBulkLoading(false);
                    return;
                }

                console.log(`Found ${matchups.length} matchups`);

                // Get all players for the selected team or all teams
                let playerQuery = supabaseClient
                    .from('player_cover_stats')
                    .select('player_name, team, tprr_player')
                    .eq('season', SEASON)
                    .eq('coverage_type', 'Overall')
                    .order('tprr_player', { ascending: false }); // Order by target rate

                if (team) {
                    playerQuery = playerQuery.eq('team', team);
                }

                console.log('Fetching players...');
                const { data: players, error: playerError } = await playerQuery;

                if (playerError) {
                    console.error('Players error:', playerError);
                    throw new Error('Error fetching players: ' + playerError.message);
                }

                if (!players || players.length === 0) {
                    console.warn('No players found for the selected criteria.');
                    showError('No players found for the selected criteria. Please adjust filters or ensure player data exists.');
                    showBulkLoading(false);
                    return;
                }

                console.log(`Found ${players.length} players`);

                // Get unique players and limit to top 50 by target rate
                const uniquePlayers = Array.from(new Map(players.map(p => [p.player_name, p])).values())
                                        .slice(0, 50); // Limit to top 50 players by target rate
                
                updateProgress(0, `Starting analysis of top ${uniquePlayers.length} players...`);

                // Process each player against their matchups
                for (let i = 0; i < uniquePlayers.length; i++) {
                    const player = uniquePlayers[i];
                    // Update progress more consistently
                    updateProgress(((i + 1) / uniquePlayers.length) * 100, `Analyzing ${player.player_name}...`);

                    // Find matchups for this player's team
                    const playerMatchups = matchups.filter(m => 
                        m.home_team === player.team || m.away_team === player.team
                    );

                    for (const matchup of playerMatchups) {
                        const opponent = matchup.home_team === player.team ? matchup.away_team : matchup.home_team;
                        
                        try {
                            const result = await calculatePlayerProjection(
                                player.player_name,
                                opponent,
                                gameFlow,
                                35, // Default routes per game
                                5.5 // Default betting line for comparison
                            );

                            if (result) {
                                bulkResults.push({
                                    ...result,
                                    week: matchup.week,
                                    matchup: `${player.team} ${matchup.home_team === player.team ? 'vs' : '@'} ${opponent}`
                                });
                            }
                        } catch (error) {
                            // Log the error but don't stop the entire bulk analysis for one player
                            console.warn(`Skipping projection for ${player.player_name} vs ${opponent} due to error: ${error.message}`);
                        }
                    }
                }

                // Sort results by projected receptions (highest first)
                bulkResults.sort((a, b) => parseFloat(b.expectedReceptions) - parseFloat(a.expectedReceptions));

                // Limit to top 50 results (already limited uniquePlayers to 50, but this re-limits final results if many matchups per player)
                bulkResults = bulkResults.slice(0, 50);

                displayBulkResults();

            } catch (error) {
                console.error('Bulk analysis failed:', error);
                showError(error.message);
            } finally {
                showBulkLoading(false);
            }
        }

        async function calculatePlayerProjection(playerName, opponentTeam, gameFlow, routesPerGame, bettingLine) {
            // This function is called internally by runBulkAnalysis and calculateProjection,
            // so the supabaseClient check is handled by the calling function.
            // However, for direct calls, it would need its own check.

            try {
                // Get player's team and overall stats
                const { data: playerData, error: playerError } = await supabaseClient
                    .from('player_cover_stats')
                    .select('team, tprr_player')
                    .eq('player_name', playerName)
                    .eq('season', SEASON)
                    .eq('coverage_type', 'Overall')
                    .limit(1);

                if (playerError) {
                    throw new Error(`Player data error for ${playerName}: ${playerError.message}`);
                }

                if (!playerData || playerData.length === 0) {
                    throw new Error(`Player "${playerName}" not found or no overall stats.`);
                }

                const playerTeam = playerData[0].team;
                const targetShare = (playerData[0].tprr_player * 100).toFixed(1);

                // Get opponent's coverage frequencies
                const { data: coverageData, error: coverageError } = await supabaseClient
                    .from('defensive_coverages')
                    .select('*')
                    .eq('team_name', opponentTeam)
                    .eq('season', SEASON)
                    .limit(1);

                if (coverageError) {
                    throw new Error(`Coverage data error for ${opponentTeam}: ${coverageError.message}`);
                }

                if (!coverageData || coverageData.length === 0) {
                    // Use default coverage if not found
                    console.warn(`No defensive coverage data for ${opponentTeam}, using defaults for calculation.`);
                    const defaultCoverage = {
                        man_pct: 25,
                        cover_2_pct: 15,
                        cover_3_pct: 35,
                        cover_4_pct: 15,
                        cover_6_pct: 10
                    };
                    
                    const result = calculateSimpleProjection(playerName, playerTeam, opponentTeam, targetShare, routesPerGame, gameFlow);
                    return {
                        ...result,
                        bettingLine: bettingLine
                    };
                }

                const coverage = coverageData[0];
                
                const coverageTypes = [
                    { name: 'Man Coverage', pct: coverage.man_pct },
                    { name: 'Cover 2', pct: coverage.cover_2_pct },
                    { name: 'Cover 3', pct: coverage.cover_3_pct },
                    { name: 'Cover 4', pct: coverage.cover_4_pct },
                    { name: 'Cover 6', pct: coverage.cover_6_pct }
                ];

                // Get player stats for ALL coverage types
                const { data: playerStats, error: statsError } = await supabaseClient
                    .from('player_cover_stats')
                    .select('coverage_type, tprr_player, separation_score')
                    .eq('player_name', playerName)
                    .eq('team', playerTeam)
                    .eq('season', SEASON)
                    .in('coverage_type', ['Man Coverage', 'Cover 2', 'Cover 3', 'Cover 4', 'Cover 6']);

                if (statsError) {
                    throw new Error(`Player coverage stats error for ${playerName}: ${statsError.message}`);
                }

                if (!playerStats || playerStats.length === 0) {
                    // Use simple projection if no detailed stats
                    console.warn(`No detailed coverage stats for ${playerName}, using simple projection.`);
                    const result = calculateSimpleProjection(playerName, playerTeam, opponentTeam, targetShare, routesPerGame, gameFlow);
                    return {
                        ...result,
                        bettingLine: bettingLine
                    };
                }

                // Calculate weighted TPRR and separation scores
                let weightedTPRR = 0;
                let weightedSeparation = 0;
                let totalWeight = 0;

                coverageTypes.forEach(coverage => {
                    if (coverage.pct > 0) {
                        const playerStat = playerStats.find(s => s.coverage_type === coverage.name);
                        if (playerStat) {
                            const weight = coverage.pct / 100;
                            weightedTPRR += (playerStat.tprr_player * 100) * weight;
                            weightedSeparation += (playerStat.separation_score || 0.2) * weight;
                            totalWeight += weight;
                        }
                    }
                });

                if (totalWeight === 0) {
                    console.warn(`No valid coverage data for ${playerName} to calculate weighted scores. Using simple projection.`);
                    const result = calculateSimpleProjection(playerName, playerTeam, opponentTeam, targetShare, routesPerGame, gameFlow);
                    return {
                        ...result,
                        bettingLine: bettingLine
                    };
                }

                const stats = {
                    tprr_player: weightedTPRR / totalWeight,
                    separation_score: weightedSeparation / totalWeight
                };

                const mostFrequent = coverageTypes.filter(c => c.pct > 0).sort((a, b) => b.pct - a.pct)[0] || { name: 'Cover 3', pct: 30 };

                // Get defensive matchup stats (optional)
                const { data: defStats } = await supabaseClient
                    .from('defensive_matchups')
                    .select('tprr_allowed, catch_rate_allowed')
                    .eq('defensive_team_name', opponentTeam)
                    .eq('season', SEASON)
                    .eq('coverage_type', mostFrequent.name)
                    .limit(1);

                const defMatchup = defStats && defStats[0] ? defStats[0] : { tprr_allowed: 0.185, catch_rate_allowed: 63 };

                const result = calculateReceptionScore(
                    stats.tprr_player,
                    stats.separation_score,
                    parseFloat(targetShare),
                    routesPerGame,
                    gameFlow,
                    mostFrequent.pct,
                    defMatchup.tprr_allowed * 100,
                    defMatchup.catch_rate_allowed
                );

                const projection = parseFloat(result.expectedReceptions);
                const edgeScore = projection - bettingLine;

                return {
                    playerName,
                    playerTeam,
                    opponentTeam,
                    targetShare,
                    tprr: stats.tprr_player.toFixed(1),
                    sepScore: stats.separation_score.toFixed(3),
                    expectedReceptions: result.expectedReceptions,
                    bettingLine: bettingLine,
                    edgeScore: edgeScore
                };

            } catch (error) {
                console.error(`Error in calculatePlayerProjection for ${playerName} vs ${opponentTeam}:`, error);
                throw error; // Re-throw to be caught by the calling function (runBulkAnalysis or calculateProjection)
            }
        }

        function calculateSimpleProjection(playerName, playerTeam, opponentTeam, targetShare, routesPerGame, gameFlow) {
            // Simple projection when detailed data is not available
            const gameScriptMultiplier = 0.85 + (gameFlow * 0.075);
            // Fallback TPRR if not available, or use the targetShare itself
            const effectiveTPRR = parseFloat(targetShare) / 100; 
            const baseProjection = routesPerGame * effectiveTPRR * 0.65 * gameScriptMultiplier; // 65% catch rate assumption
            
            return {
                playerName,
                playerTeam,
                opponentTeam,
                targetShare,
                tprr: (effectiveTPRR * 100).toFixed(1), // Display as percentage
                sepScore: "0.200", // Default separation
                expectedReceptions: baseProjection.toFixed(1),
                edgeScore: 0
            };
        }

        function displayBulkResults() {
            const resultsCount = document.getElementById('resultsCount');
            const resultsList = document.getElementById('bulkResultsList');
            
            resultsCount.textContent = `Top ${bulkResults.length} players by projected receptions`;
            
            if (bulkResults.length === 0) {
                resultsList.innerHTML = '<div class="loading">No players found matching criteria or no projections generated.</div>';
                document.getElementById('bulkResults').style.display = 'block';
                return;
            }

            resultsList.innerHTML = bulkResults.map((result, index) => `
                <div class="bulk-result-item">
                    <div class="result-header">
                        <div>
                            <div class="player-info">#${index + 1} ${result.playerName} (${result.playerTeam})</div>
                            <div class="matchup-info">Week ${result.week} - ${result.matchup}</div>
                        </div>
                        <div class="projection-score">
                            ${result.expectedReceptions} rec
                        </div>
                    </div>
                    <div class="result-details">
                        <div class="detail-item">
                            <div class="detail-label">Projection</div>
                            <div class="detail-value">${result.expectedReceptions}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Target Share</div>
                            <div class="detail-value">${result.targetShare}%</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">TPRR</div>
                            <div class="detail-value">${result.tprr}%</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Separation</div>
                            <div class="detail-value">${result.sepScore}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">vs</div>
                            <div class="detail-value">${result.opponentTeam}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Week</div>
                            <div class="detail-value">${result.week}</div>
                        </div>
                    </div>
                </div>
            `).join('');

            document.getElementById('bulkResults').style.display = 'block';
        }

        function updateProgress(percentage, text) {
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            
            progressFill.style.width = percentage + '%';
            progressText.textContent = text;
        }

        function showBulkLoading(show) {
            document.getElementById('bulkProgress').style.display = show ? 'block' : 'none';
        }

        function hideBulkResults() {
            document.getElementById('bulkResults').style.display = 'none';
        }

        function exportResults() {
            if (bulkResults.length === 0) return;

            const csvContent = [
                ['Rank', 'Player', 'Team', 'Week', 'Matchup', 'Opponent', 'Projection', 'Target Share', 'TPRR', 'Separation'].join(','),
                ...bulkResults.map((result, index) => [
                    index + 1,
                    result.playerName,
                    result.playerTeam,
                    result.week,
                    result.matchup,
                    result.opponentTeam,
                    result.expectedReceptions,
                    result.targetShare + '%',
                    result.tprr + '%',
                    result.sepScore
                ].join(','))
            ].join('\n');

            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `nfl-top-projections-${new Date().toISOString().split('T')[0]}.csv`;
            a.click();
            window.URL.revokeObjectURL(url);
        }

        function normalizeTeamName(input) {
            const teamMapping = {
                'ARI': 'Arizona Cardinals', 'ATL': 'Atlanta Falcons', 'BAL': 'Baltimore Ravens',
                'BUF': 'Buffalo Bills', 'CAR': 'Carolina Panthers', 'CHI': 'Chicago Bears',
                'CIN': 'Cincinnati Bengals', 'CLE': 'Cleveland Browns', 'DAL': 'Dallas Cowboys',
                'DEN': 'Denver Broncos', 'DET': 'Detroit Lions', 'GB': 'Green Bay Packers',
                'HOU': 'Houston Texans', 'IND': 'Indianapolis Colts', 'JAX': 'Jacksonville Jaguars',
                'KC': 'Kansas City Chiefs', 'LV': 'Las Vegas Raiders', 'LAC': 'Los Angeles Chargers',
                'LAR': 'Los Angeles Rams', 'MIA': 'Miami Dolphins', 'MIN': 'Minnesota Vikings',
                'NE': 'New England Patriots', 'NO': 'New Orleans Saints', 'NYG': 'New York Giants',
                'NYJ': 'New York Jets', 'PHI': 'Philadelphia Eagles', 'PIT': 'Pittsburgh Steelers',
                'SF': 'San Francisco 49ers', 'SEA': 'Seattle Seahawks', 'TB': 'Tampa Bay Buccaneers',
                'TEN': 'Tennessee Titans', 'WAS': 'Washington Commanders'
            };
            
            const upperInput = input.trim().toUpperCase();
            if (teamMapping[upperInput]) {
                return teamMapping[upperInput];
            }
            
            for (const fullName of Object.values(teamMapping)) {
                if (input.trim().toLowerCase() === fullName.toLowerCase()) {
                    return fullName;
                }
            }
            
            return input.trim();
        }

        async function calculateProjection() {
            const playerName = document.getElementById('playerName').value.trim();
            const opponentTeam = normalizeTeamName(document.getElementById('opponentTeam').value);
            const gameFlow = parseInt(document.getElementById('gameFlow').value);
            const routesPerGame = parseInt(document.getElementById('routesPerGame').value);
            const bettingLine = parseFloat(document.getElementById('bettingLine').value);

            if (!playerName || !opponentTeam || !routesPerGame || !bettingLine) {
                showError('Please fill in all fields');
                return;
            }
            
            // CRITICAL CHECK: Ensure supabaseClient is ready
            if (!supabaseClient) {
                showError('Supabase client not initialized. Cannot calculate projection. Please refresh the page.');
                showLoading(false);
                return; // Stop execution if client isn't ready
            }

            showLoading(true);
            hideError();
            hideResults();

            try {
                // 1. Get player's team and overall stats
                const { data: playerData, error: playerError } = await supabaseClient
                    .from('player_cover_stats')
                    .select('team, tprr_player')
                    .eq('player_name', playerName)
                    .eq('season', SEASON)
                    .eq('coverage_type', 'Overall')
                    .limit(1);

                if (playerError || !playerData || playerData.length === 0) {
                    throw new Error(`Player "${playerName}" not found in database or no overall stats for them.`);
                }

                const playerTeam = playerData[0].team;
                const targetShare = (playerData[0].tprr_player * 100).toFixed(1);

                // 2. Get opponent's coverage frequencies
                const { data: coverageData, error: coverageError } = await supabaseClient
                    .from('defensive_coverages')
                    .select('*')
                    .eq('team_name', opponentTeam)
                    .eq('season', SEASON)
                    .limit(1);

                if (coverageError || !coverageData || coverageData.length === 0) {
                    // Fallback to a message for missing defense data
                    console.warn(`No defensive coverage data found for ${opponentTeam}. Using default values.`);
                    const result = calculateSimpleProjection(playerName, playerTeam, opponentTeam, targetShare, routesPerGame, gameFlow);
                    displayResults({
                        playerName,
                        playerTeam,
                        opponentTeam,
                        coverageType: "Default Coverage", // Indicate default was used
                        coverageFreq: 100,
                        coverageBreakdown: [], // Empty breakdown for default
                        targetShare,
                        tprr: result.tprr,
                        sepScore: result.sepScore,
                        expectedReceptions: result.expectedReceptions,
                        receptionScore: result.edgeScore, // Using edgeScore as a generic score if no full model
                        bettingLine: bettingLine
                    });
                    return; // Exit after displaying simple projection
                }

                const coverage = coverageData[0];
                
                // Define coverage types for weighted analysis
                const coverageTypes = [
                    { name: 'Man Coverage', pct: coverage.man_pct },
                    { name: 'Cover 2', pct: coverage.cover_2_pct },
                    { name: 'Cover 3', pct: coverage.cover_3_pct },
                    { name: 'Cover 4', pct: coverage.cover_4_pct },
                    { name: 'Cover 6', pct: coverage.cover_6_pct }
                ];

                // 3. Get player stats for ALL coverage types
                const { data: playerStats, error: statsError } = await supabaseClient
                    .from('player_cover_stats')
                    .select('coverage_type, tprr_player, separation_score')
                    .eq('player_name', playerName)
                    .eq('team', playerTeam)
                    .eq('season', SEASON)
                    .in('coverage_type', ['Man Coverage', 'Cover 2', 'Cover 3', 'Cover 4', 'Cover 6']);

                if (statsError || !playerStats || playerStats.length === 0) {
                    // Fallback to simple projection if no detailed player coverage stats
                    console.warn(`No detailed coverage stats found for ${playerName}. Using simple projection.`);
                    const result = calculateSimpleProjection(playerName, playerTeam, opponentTeam, targetShare, routesPerGame, gameFlow);
                    displayResults({
                        playerName,
                        playerTeam,
                        opponentTeam,
                        coverageType: "Simple Projection", // Indicate simple was used
                        coverageFreq: 100,
                        coverageBreakdown: [],
                        targetShare,
                        tprr: result.tprr,
                        sepScore: result.sepScore,
                        expectedReceptions: result.expectedReceptions,
                        receptionScore: result.edgeScore,
                        bettingLine: bettingLine
                    });
                    return; // Exit after displaying simple projection
                }

                // Calculate weighted TPRR and separation scores
                let weightedTPRR = 0;
                let weightedSeparation = 0;
                let totalWeight = 0;
                let coverageBreakdown = [];

                coverageTypes.forEach(coverage => {
                    if (coverage.pct > 0) {
                        const playerStat = playerStats.find(s => s.coverage_type === coverage.name);
                        if (playerStat) {
                            const weight = coverage.pct / 100;
                            weightedTPRR += (playerStat.tprr_player * 100) * weight;
                            weightedSeparation += (playerStat.separation_score || 0.2) * weight;
                            totalWeight += weight;
                            
                            coverageBreakdown.push({
                                name: coverage.name,
                                frequency: coverage.pct,
                                playerTPRR: (playerStat.tprr_player * 100).toFixed(1)
                            });
                        }
                    }
                });

                if (totalWeight === 0) {
                     // Fallback to simple projection if weighted calculation cannot be performed
                    console.warn(`No valid coverage data found for ${playerName} to calculate weighted scores. Using simple projection.`);
                    const result = calculateSimpleProjection(playerName, playerTeam, opponentTeam, targetShare, routesPerGame, gameFlow);
                    displayResults({
                        playerName,
                        playerTeam,
                        opponentTeam,
                        coverageType: "Simple Projection",
                        coverageFreq: 100,
                        coverageBreakdown: [],
                        targetShare,
                        tprr: result.tprr,
                        sepScore: result.sepScore,
                        expectedReceptions: result.expectedReceptions,
                        receptionScore: result.edgeScore,
                        bettingLine: bettingLine
                    });
                    return; // Exit after displaying simple projection
                }

                // Normalize weighted averages
                const stats = {
                    tprr_player: weightedTPRR / totalWeight,
                    separation_score: weightedSeparation / totalWeight
                };

                // Find most frequent coverage for display
                const mostFrequent = coverageTypes.filter(c => c.pct > 0).sort((a, b) => b.pct - a.pct)[0] || { name: 'Cover 3', pct: 30 };

                // 4. Get defensive matchup stats
                const { data: defStats, error: defError } = await supabaseClient
                    .from('defensive_matchups')
                    .select('tprr_allowed, catch_rate_allowed')
                    .eq('defensive_team_name', opponentTeam)
                    .eq('season', SEASON)
                    .eq('coverage_type', mostFrequent.name)
                    .limit(1);
                
                // Use default defensive matchup stats if not found
                const defMatchup = defStats && defStats[0] ? defStats[0] : { tprr_allowed: 0.185, catch_rate_allowed: 63 };
                if (!defStats || defStats.length === 0) {
                    console.warn(`No specific defensive matchup stats for ${opponentTeam} in ${mostFrequent.name} coverage. Using default.`);
                }

                // 5. Calculate score using weighted stats
                const result = calculateReceptionScore(
                    stats.tprr_player,
                    stats.separation_score,
                    parseFloat(targetShare),
                    routesPerGame,
                    gameFlow,
                    mostFrequent.pct,
                    defMatchup.tprr_allowed * 100,
                    defMatchup.catch_rate_allowed
                );

                // Display results
                displayResults({
                    playerName,
                    playerTeam,
                    opponentTeam,
                    coverageType: "Weighted Analysis",
                    coverageFreq: 100,
                    coverageBreakdown,
                    targetShare,
                    tprr: stats.tprr_player.toFixed(1),
                    sepScore: stats.separation_score.toFixed(3),
                    expectedReceptions: result.expectedReceptions,
                    receptionScore: result.finalScore,
                    bettingLine: bettingLine
                });

            } catch (error) {
                showError(error.message);
            } finally {
                showLoading(false);
            }
        }

        function calculateReceptionScore(weightedTPRR, weightedSeparation, targetShare, routesPerGame, gameFlow, primaryCoverageFreq, defTPRR, defCatchRate) {
            // === ADVANCED STATISTICAL MODEL ===
            
            // 1. EFFICIENCY COMPONENT (40% weight)
            const tprrZScore = (weightedTPRR - 18.5) / 5.0;
            const efficiencyScore = Math.max(0, 50 + (tprrZScore * 15));
            
            // 2. VOLUME COMPONENT (30% weight)
            const totalOpportunity = (targetShare / 100) * routesPerGame;
            const volumeScore = Math.min(totalOpportunity * 2.5, 100);
            
            // 3. SEPARATION COMPONENT (15% weight) 
            const separationZScore = (weightedSeparation - 0.20) / 0.05;
            const separationScore = Math.max(0, 50 + (separationZScore * 12));
            
            // 4. DEFENSIVE MATCHUP COMPONENT (15% weight)
            const defTPRRZScore = (defTPRR - 18.5) / 3.0;
            const defCatchZScore = (defCatchRate - 63.0) / 5.0;
            const matchupScore = 50 + (defTPRRZScore * 10) + (defCatchZScore * 8);
            
            // 5. GAME SCRIPT MULTIPLIER
            const gameScriptMultiplier = 0.85 + (gameFlow * 0.075);
            
            // === COMBINE COMPONENTS ===
            const baseScore = (efficiencyScore * 0.40) + 
                            (volumeScore * 0.30) + 
                            (separationScore * 0.15) + 
                            (matchupScore * 0.15);
            
            const finalScore = Math.min(baseScore * gameScriptMultiplier, 100);
            
            // === EXPECTED RECEPTIONS CALCULATION ===
            const baseReceptions = routesPerGame * (weightedTPRR / 100) * (defCatchRate / 100) * gameScriptMultiplier;
            
            let confidenceFactor = 1.0;
            if (finalScore >= 80) confidenceFactor = 1.15;
            else if (finalScore >= 65) confidenceFactor = 1.05;
            else if (finalScore >= 35) confidenceFactor = 1.0;
            else if (finalScore >= 20) confidenceFactor = 0.95;
            else confidenceFactor = 0.85;
            
            const expectedReceptions = (baseReceptions * confidenceFactor).toFixed(1);
            
            return {
                finalScore: finalScore.toFixed(1),
                expectedReceptions
            };
        }

        function displayResults(data) {
            // Construct coverage info for display
            let coverageInfoHtml = `<h4>Coverage Analysis</h4>`;
            if (data.coverageBreakdown && data.coverageBreakdown.length > 0) {
                coverageInfoHtml += `<p>Defensive coverages faced by ${data.opponentTeam}:</p><ul>`;
                data.coverageBreakdown.forEach(item => {
                    coverageInfoHtml += `<li>${item.name}: ${item.frequency}% (Player TPRR: ${item.playerTPRR}%)</li>`;
                });
                coverageInfoHtml += `</ul>`;
            } else if (data.coverageType === "Weighted Analysis") {
                coverageInfoHtml += `<p>All defensive coverages analyzed by frequency</p>`;
            } else {
                coverageInfoHtml += `<p>${data.coverageType} used due to missing detailed data for player or defense.</p>`;
            }
            document.getElementById('coverageInfo').innerHTML = coverageInfoHtml;
            
            const projection = parseFloat(data.expectedReceptions);
            const line = data.bettingLine;
            const edgeDifference = projection - line;
            const edgeScore = (edgeDifference >= 0 ? '+' : '') + edgeDifference.toFixed(1);
            
            document.getElementById('playerDisplay').textContent = `${data.playerName} (${data.playerTeam})`;
            document.getElementById('defenseDisplay').textContent = data.opponentTeam;
            document.getElementById('targetShare').textContent = `${data.targetShare}%`;
            document.getElementById('tprrDisplay').textContent = `${data.tprr}%`;
            document.getElementById('sepScoreDisplay').textContent = data.sepScore;
            document.getElementById('expectedReceptions').textContent = data.expectedReceptions;
            document.getElementById('finalScore').textContent = edgeScore;

            let interpretation = '';
            let interpretClass = '';

            if (edgeDifference >= 1.5) {
                interpretation = 'GOOD EDGE - Significant positive value';
                interpretClass = 'score-high';
            } else if (edgeDifference >= 0.5) { // Slightly lowered threshold for medium
                interpretation = 'MODERATE EDGE - Positive value, consider';
                interpretClass = 'score-medium';
            } else if (edgeDifference >= 0) {
                interpretation = 'SLIGHT EDGE - Proceed with caution';
                interpretClass = 'score-medium';
            }
            else if (edgeDifference > -0.5) { // Added a slightly negative range to medium
                interpretation = 'NEUTRAL EDGE - Minimal difference';
                interpretClass = 'score-medium';
            }
            else {
                interpretation = 'POOR EDGE - Negative value, avoid bet';
                interpretClass = 'score-low';
            }

            const interpretDiv = document.getElementById('interpretation');
            interpretDiv.textContent = interpretation;
            interpretDiv.className = 'score-interpretation ' + interpretClass;

            document.getElementById('results').style.display = 'block';
        }

        function showLoading(show) {
            document.getElementById('loadingDiv').style.display = show ? 'block' : 'none';
        }

        function showError(message) {
            const errorDiv = document.getElementById('errorDiv');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        function hideError() {
            document.getElementById('errorDiv').style.display = 'none';
        }

        function hideResults() {
            document.getElementById('results').style.display = 'none';
        }

        // Autocomplete functionality
        async function setupAutocomplete() {
            await loadPlayerNames(); // Ensure player names are loaded before autocomplete setup
            setupPlayerAutocomplete();
            setupTeamAutocomplete();
        }

        async function loadPlayerNames() {
            // CRITICAL CHECK: Ensure supabaseClient is ready
            if (!supabaseClient) {
                console.warn('Supabase client not initialized when attempting to load player names for autocomplete.');
                return; // Exit if client not ready
            }
            try {
                const { data, error } = await supabaseClient
                    .from('player_cover_stats')
                    .select('player_name')
                    .eq('season', SEASON)
                    .eq('coverage_type', 'Overall');
                
                if (data) {
                    const uniqueNames = [...new Set(data.map(player => player.player_name))];
                    playerList = uniqueNames.sort();
                    console.log('Player names loaded for autocomplete.');
                }
                if (error) {
                    console.error('Error loading player names for autocomplete:', error);
                    // This error might not be critical enough to show to the user immediately,
                    // but it's important for debugging.
                }
            } catch (error) {
                console.error('Error loading player names (catch block):', error);
            }
        }

        function setupPlayerAutocomplete() {
            const input = document.getElementById('playerName');
            const suggestions = document.getElementById('playerSuggestions');
            
            input.addEventListener('input', function() {
                const value = this.value.toLowerCase();
                selectedIndex = -1;
                
                if (value.length < 2) {
                    suggestions.style.display = 'none';
                    return;
                }
                
                const filtered = playerList.filter(player => 
                    player.toLowerCase().includes(value)
                ).slice(0, 8);
                
                if (filtered.length > 0) {
                    suggestions.innerHTML = filtered.map(player => 
                        `<div class="autocomplete-suggestion">${player}</div>`
                    ).join('');
                    suggestions.style.display = 'block';
                    
                    suggestions.querySelectorAll('.autocomplete-suggestion').forEach((item, index) => {
                        item.addEventListener('click', () => {
                            input.value = item.textContent;
                            suggestions.style.display = 'none';
                        });
                    });
                } else {
                    suggestions.style.display = 'none';
                }
            });
            
            input.addEventListener('keydown', function(e) {
                const items = suggestions.querySelectorAll('.autocomplete-suggestion');
                
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    selectedIndex = Math.min(selectedIndex + 1, items.length - 1);
                    updateSelection(items);
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    selectedIndex = Math.max(selectedIndex - 1, -1);
                    updateSelection(items);
                } else if (e.key === 'Enter' && selectedIndex >= 0) {
                    e.preventDefault();
                    input.value = items[selectedIndex].textContent;
                    suggestions.style.display = 'none';
                } else if (e.key === 'Escape') {
                    suggestions.style.display = 'none';
                }
            });
            
            document.addEventListener('click', function(e) {
                if (!input.contains(e.target) && !suggestions.contains(e.target)) {
                    suggestions.style.display = 'none';
                }
            });
        }

        function setupTeamAutocomplete() {
            const input = document.getElementById('opponentTeam');
            const suggestions = document.getElementById('teamSuggestions');
            
            const teams = [
                'Arizona Cardinals', 'Atlanta Falcons', 'Baltimore Ravens', 'Buffalo Bills',
                'Carolina Panthers', 'Chicago Bears', 'Cincinnati Bengals', 'Cleveland Browns',
                'Dallas Cowboys', 'Denver Broncos', 'Detroit Lions', 'Green Bay Packers',
                'Houston Texans', 'Indianapolis Colts', 'Jacksonville Jaguars', 'Kansas City Chiefs',
                'Las Vegas Raiders', 'Los Angeles Chargers', 'Los Angeles Rams', 'Miami Dolphins',
                'Minnesota Vikings', 'New England Patriots', 'New Orleans Saints', 'New York Giants',
                'New York Jets', 'Philadelphia Eagles', 'Pittsburgh Steelers', 'San Francisco 49ers',
                'Seattle Seahawks', 'Tampa Bay Buccaneers', 'Tennessee Titans', 'Washington Commanders'
            ];
            
            input.addEventListener('input', function() {
                const value = this.value.toLowerCase();
                selectedIndex = -1;
                
                if (value.length < 1) {
                    suggestions.style.display = 'none';
                    return;
                }
                
                const filtered = teams.filter(team => 
                    team.toLowerCase().includes(value) || 
                    normalizeTeamName(value).toLowerCase() === team.toLowerCase() // Also check abbreviation match
                ).slice(0, 8);
                
                if (filtered.length > 0) {
                    suggestions.innerHTML = filtered.map(team => 
                        `<div class="autocomplete-suggestion">${team}</div>`
                    ).join('');
                    suggestions.style.display = 'block';
                    
                    suggestions.querySelectorAll('.autocomplete-suggestion').forEach((item, index) => {
                        item.addEventListener('click', () => {
                            input.value = item.textContent;
                            suggestions.style.display = 'none';
                        });
                    });
                } else {
                    suggestions.style.display = 'none';
                }
            });
            
            input.addEventListener('keydown', function(e) {
                const items = suggestions.querySelectorAll('.autocomplete-suggestion');
                
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    selectedIndex = Math.min(selectedIndex + 1, items.length - 1);
                    updateSelection(items);
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    selectedIndex = Math.max(selectedIndex - 1, -1);
                    updateSelection(items);
                } else if (e.key === 'Enter' && selectedIndex >= 0) {
                    e.preventDefault();
                    input.value = items[selectedIndex].textContent;
                    suggestions.style.display = 'none';
                } else if (e.key === 'Escape') {
                    suggestions.style.display = 'none';
                }
            });
            
            document.addEventListener('click', function(e) {
                if (!input.contains(e.target) && !suggestions.contains(e.target)) {
                    suggestions.style.display = 'none';
                }
            });
        }

        function updateSelection(items) {
            items.forEach((item, index) => {
                if (index === selectedIndex) {
                    item.classList.add('selected');
                } else {
                    item.classList.remove('selected');
                }
            });
        }
    </script>
</body>
</html>
