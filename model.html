<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clear Edge Sports - NFL Model</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: #111a29;
            color: white;
            padding: 20px;
            line-height: 1.6;
            position: relative;
            overflow-x: hidden;
            min-height: 100vh;
        }
        
        /* Enhanced animated background - matching business site */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                linear-gradient(135deg, #111a29 0%, #1a2332 30%, #0f1419 70%, #111a29 100%);
            z-index: -2;
        }

        body::after {
            content: '';
            position: fixed;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: 
                conic-gradient(from 0deg at 25% 25%, transparent 0deg, rgba(59, 130, 246, 0.08) 45deg, transparent 90deg),
                conic-gradient(from 180deg at 75% 75%, transparent 0deg, rgba(255, 215, 0, 0.08) 45deg, transparent 90deg),
                conic-gradient(from 90deg at 50% 50%, transparent 0deg, rgba(139, 69, 19, 0.05) 30deg, transparent 60deg);
            animation: rotate 25s linear infinite;
            z-index: -1;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .password-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        
        .password-container {
            background: rgba(255, 255, 255, 0.03);
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 20px;
            padding: 50px;
            text-align: center;
            max-width: 450px;
            width: 100%;
            backdrop-filter: blur(15px);
            position: relative;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.3);
        }

        .password-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, #FFD700, transparent);
            animation: shimmer 3s ease-in-out infinite alternate;
        }

        @keyframes shimmer {
            0% { opacity: 0.3; }
            100% { opacity: 1; }
        }
        
        .password-title {
            font-size: 28px;
            font-weight: 900;
            color: #FFD700;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 3px;
            text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.5);
        }

        .password-subtitle {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 30px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .password-input {
            width: 100%;
            padding: 18px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 12px;
            color: white;
            font-size: 18px;
            text-align: center;
            letter-spacing: 2px;
            transition: all 0.3s ease;
            margin: 20px 0;
            outline: none;
            font-weight: 600;
        }

        .password-input:focus {
            border-color: #FFD700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
            transform: scale(1.02);
        }

        .password-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
            font-weight: 400;
        }
        
        .password-submit {
            width: 100%;
            padding: 15px 40px;
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            color: #111a29;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 800;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 5px 20px rgba(255, 215, 0, 0.3);
        }

        .password-submit:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 8px 25px rgba(255, 215, 0, 0.5);
        }
        
        .password-error {
            color: #ff4444;
            font-size: 14px;
            margin-top: 15px;
            display: none;
            font-weight: 600;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3);
        }
        
        .main-content {
            display: none;
            position: relative;
            z-index: 1;
        }
        
        .container {
            max-width: 1000px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            color: white;
            margin-bottom: 40px;
            font-size: 3rem;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 3px;
            text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.5);
        }

        .model-subtitle {
            text-align: center;
            color: #FFD700;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: 700;
            margin-bottom: 40px;
        }

        .calculation-mode {
            display: flex;
            justify-content: center;
            margin-bottom: 30px;
        }

        .mode-btn {
            padding: 12px 24px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 12px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 0 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .mode-btn.active {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            color: #111a29;
            border-color: #FFD700;
        }

        .mode-btn:hover {
            border-color: #FFD700;
            transform: translateY(-2px);
        }
        
        .input-card {
            background: rgba(255, 255, 255, 0.03);
            border: 2px solid rgba(255, 215, 0, 0.15);
            border-radius: 20px;
            padding: 30px;
            backdrop-filter: blur(15px);
            position: relative;
            overflow: hidden;
            margin-bottom: 30px;
        }

        .input-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, #FFD700, transparent);
            animation: shimmer 3s ease-in-out infinite alternate;
        }

        .bulk-section {
            display: none;
        }

        .bulk-filters {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .input-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            color: #FFD700;
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        input[type="text"], input[type="number"], select {
            width: 100%;
            padding: 12px 15px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 8px;
            color: white;
            font-size: 16px;
            transition: all 0.3s ease;
            outline: none;
        }
        
        input:focus, select:focus {
            border-color: #FFD700;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.2);
            background: rgba(255, 255, 255, 0.15);
        }

        input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }
        
        .calculate-btn {
            width: 100%;
            padding: 18px;
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            color: #111a29;
            border: none;
            border-radius: 12px;
            font-size: 18px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 20px;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 5px 20px rgba(255, 215, 0, 0.3);
        }
        
        .calculate-btn:hover {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 8px 25px rgba(255, 215, 0, 0.5);
        }
        
        .calculate-btn:active {
            transform: translateY(0);
        }

        .bulk-results {
            background: rgba(255, 255, 255, 0.03);
            border: 2px solid rgba(255, 215, 0, 0.15);
            border-radius: 20px;
            padding: 30px;
            backdrop-filter: blur(15px);
            position: relative;
            overflow: hidden;
            margin-top: 30px;
        }

        .bulk-results::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, #FFD700, transparent);
            animation: shimmer 3s ease-in-out infinite alternate;
        }

        .bulk-results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid rgba(255, 215, 0, 0.3);
        }

        .results-count {
            color: #FFD700;
            font-size: 16px;
            font-weight: 600;
        }

        .export-btn {
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.1);
            color: #FFD700;
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 8px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }

        .export-btn:hover {
            background: rgba(255, 215, 0, 0.1);
            border-color: #FFD700;
        }

        .bulk-result-item {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 215, 0, 0.2);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
            transition: all 0.3s ease;
        }

        .bulk-result-item:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 215, 0, 0.4);
            transform: translateY(-2px);
        }

        .result-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .player-info {
            font-size: 16px;
            font-weight: 700;
            color: white;
        }

        .matchup-info {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.7);
        }

        .projection-score {
            font-size: 20px;
            font-weight: 800;
            padding: 5px 12px;
            border-radius: 8px;
            background: rgba(255, 215, 0, 0.2);
            color: #FFD700;
            border: 1px solid rgba(255, 215, 0, 0.3);
        }

        .result-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin-top: 10px;
            font-size: 12px;
        }

        .detail-item {
            text-align: center;
        }

        .detail-label {
            color: #FFD700;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 3px;
        }

        .detail-value {
            color: rgba(255, 255, 255, 0.9);
            font-weight: 600;
        }
        
        .results {
            background: rgba(255, 255, 255, 0.03);
            border: 2px solid rgba(255, 215, 0, 0.15);
            border-radius: 20px;
            padding: 30px;
            backdrop-filter: blur(15px);
            position: relative;
            overflow: hidden;
        }

        .results::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, #FFD700, transparent);
            animation: shimmer 3s ease-in-out infinite alternate;
        }
        
        .result-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 0;
            border-bottom: 1px solid rgba(255, 215, 0, 0.2);
        }
        
        .result-item:last-child {
            border-bottom: none;
        }
        
        .result-label {
            color: #FFD700;
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .result-value {
            font-size: 18px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.9);
        }
        
        .final-score {
            font-size: 32px !important;
            color: #FFD700 !important;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
        }
        
        .score-interpretation {
            margin-top: 20px;
            padding: 15px;
            border-radius: 12px;
            text-align: center;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .score-high {
            background: rgba(34, 197, 94, 0.1);
            border: 2px solid rgba(34, 197, 94, 0.3);
            color: #22c55e;
        }
        
        .score-medium {
            background: rgba(255, 215, 0, 0.1);
            border: 2px solid rgba(255, 215, 0, 0.3);
            color: #FFD700;
        }
        
        .score-low {
            background: rgba(239, 68, 68, 0.1);
            border: 2px solid rgba(239, 68, 68, 0.3);
            color: #ef4444;
        }
        
        .info-text {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
            margin-top: 5px;
            font-style: italic;
        }

        .autocomplete-container {
            position: relative;
        }

        .autocomplete-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: rgba(17, 26, 41, 0.95);
            backdrop-filter: blur(15px);
            border: 2px solid rgba(255, 215, 0, 0.5);
            border-top: none;
            border-radius: 0 0 8px 8px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5);
        }

        .autocomplete-suggestion {
            padding: 12px 15px;
            color: rgba(255, 255, 255, 0.9);
            cursor: pointer;
            transition: all 0.2s ease;
            border-bottom: 1px solid rgba(255, 215, 0, 0.1);
        }

        .autocomplete-suggestion:hover,
        .autocomplete-suggestion.selected {
            background: rgba(255, 215, 0, 0.2);
            color: #FFD700;
        }

        .autocomplete-suggestion:last-child {
            border-bottom: none;
        }

        .autocomplete-suggestions::-webkit-scrollbar {
            width: 6px;
        }

        .autocomplete-suggestions::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
        }

        .autocomplete-suggestions::-webkit-scrollbar-thumb {
            background: rgba(255, 215, 0, 0.5);
            border-radius: 3px;
        }
        
        .game-context-scale {
            margin-top: 10px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
        }
        
        .loading {
            text-align: center;
            color: #FFD700;
            padding: 20px;
            font-weight: 600;
        }
        
        .error {
            text-align: center;
            color: #ef4444;
            padding: 20px;
            font-weight: 600;
        }
        
        .coverage-info {
            background: rgba(255, 215, 0, 0.1);
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .coverage-info h4 {
            color: #FFD700;
            margin-bottom: 5px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .coverage-info p {
            color: rgba(255, 255, 255, 0.8);
            font-weight: 500;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #FFD700, #FFA500);
            width: 0%;
            transition: width 0.3s ease;
        }

        .progress-text {
            text-align: center;
            color: #FFD700;
            font-size: 14px;
            font-weight: 600;
            margin-top: 5px;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            h1 {
                font-size: 2.5rem;
            }

            .password-container {
                padding: 30px 20px;
            }

            .password-title {
                font-size: 24px;
            }
            
            .input-card, .results, .bulk-results {
                padding: 20px;
            }

            .calculation-mode {
                flex-direction: column;
                align-items: center;
            }

            .mode-btn {
                margin: 5px 0;
                width: 200px;
            }

            .bulk-filters {
                grid-template-columns: 1fr;
            }

            .result-details {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="password-overlay" id="passwordOverlay">
        <div class="password-container">
            <h2 class="password-title">Clear Edge</h2>
            <p class="password-subtitle">NFL Model Access</p>
            <input type="password" class="password-input" id="passwordInput" placeholder="Enter Password" autocomplete="off">
            <button class="password-submit" id="passwordSubmit">ACCESS MODEL</button>
            <div class="password-error" id="passwordError">Incorrect password. Please try again.</div>
        </div>
    </div>

    <div class="main-content" id="mainContent">
        <div class="container">
            <h1>NFL Model</h1>
            <p class="model-subtitle">Advanced Analytics & Predictions</p>
            
            <div class="calculation-mode">
                <button class="mode-btn active" id="singleModeBtn">Single Player</button>
                <button class="mode-btn" id="bulkModeBtn">Bulk Analysis</button>
            </div>

            <div class="input-card" id="singleSection">
                <div class="input-group">
                    <label for="playerName">Player Name</label>
                    <div class="autocomplete-container">
                        <input type="text" id="playerName" placeholder="e.g., Ja'Marr Chase" autocomplete="off">
                        <div class="autocomplete-suggestions" id="playerSuggestions"></div>
                    </div>
                </div>
                
                <div class="input-group">
                    <label for="opponentTeam">Opponent Team</label>
                    <div class="autocomplete-container">
                        <input type="text" id="opponentTeam" placeholder="e.g., Jacksonville Jaguars or JAX" autocomplete="off">
                        <div class="autocomplete-suggestions" id="teamSuggestions"></div>
                    </div>
                </div>
                
                <div class="input-group">
                    <label for="gameFlow">Expected Game Flow</label>
                    <select id="gameFlow">
                        <option value="3">Neutral (Even matchup)</option>
                        <option value="1">Heavy Favorite (14+ point favorite)</option>
                        <option value="2">Slight Favorite (7-13 point favorite)</option>
                        <option value="4">Slight Underdog (7-13 point underdog)</option>
                        <option value="5">Heavy Underdog (14+ point underdog)</option>
                    </select>
                    <div class="info-text">How the game script is expected to play out</div>
                </div>
                
                <div class="input-group">
                    <label for="routesPerGame">Routes Per Game</label>
                    <input type="number" id="routesPerGame" placeholder="e.g., 35" min="0" max="60" value="35">
                    <div class="info-text">Average routes run per game by the player</div>
                </div>
                
                <div class="input-group">
                    <label for="bettingLine">Betting Line (Receptions)</label>
                    <input type="number" id="bettingLine" placeholder="e.g., 5.5" step="0.5" min="0" max="15">
                    <div class="info-text">Over/Under line for player receptions</div>
                </div>
                
                <button class="calculate-btn" id="calculateBtn">Calculate Reception Projection</button>
            </div>

            <div class="input-card bulk-section" id="bulkSection">
                <div class="bulk-filters">
                    <div class="input-group">
                        <label for="bulkWeek">Week</label>
                        <select id="bulkWeek">
                            <option value="">All Weeks</option>
                            <option value="1">Week 1</option>
                            <option value="2">Week 2</option>
                            <option value="3">Week 3</option>
                            <option value="4">Week 4</option>
                            <option value="5">Week 5</option>
                            <option value="6">Week 6</option>
                            <option value="7">Week 7</option>
                            <option value="8">Week 8</option>
                            <option value="9">Week 9</option>
                            <option value="10">Week 10</option>
                            <option value="11">Week 11</option>
                            <option value="12">Week 12</option>
                            <option value="13">Week 13</option>
                            <option value="14">Week 14</option>
                            <option value="15">Week 15</option>
                            <option value="16">Week 16</option>
                            <option value="17">Week 17</option>
                            <option value="18">Week 18</option>
                        </select>
                    </div>
                </div>
                
                <button class="calculate-btn" id="bulkCalculateBtn">Run Bulk Analysis</button>
                
                <div id="bulkProgress" style="display: none;">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                    <div class="progress-text" id="progressText">Analyzing players...</div>
                </div>
            </div>
            
            <div id="loadingDiv" class="loading" style="display: none;">
                Calculating projection...
            </div>
            
            <div id="errorDiv" class="error" style="display: none;"></div>
            
            <div class="results" id="results" style="display: none;">
                <div id="coverageInfo" class="coverage-info"></div>
                
                <div class="result-item">
                    <span class="result-label">Player</span>
                    <span class="result-value" id="playerDisplay">-</span>
                </div>
                <div class="result-item">
                    <span class="result-label">vs Defense</span>
                    <span class="result-value" id="defenseDisplay">-</span>
                </div>
                <div class="result-item">
                    <span class="result-label">Target Share</span>
                    <span class="result-value" id="targetShare">-</span>
                </div>
                <div class="result-item">
                    <span class="result-label">Weighted TPRR</span>
                    <span class="result-value" id="tprrDisplay">-</span>
                </div>
                <div class="result-item">
                    <span class="result-label">Separation Score</span>
                    <span class="result-value" id="sepScoreDisplay">-</span>
                </div>
                <div class="result-item" style="margin-top: 10px; padding-top: 20px; border-top: 2px solid #FFD700;">
                    <span class="result-label" style="font-size: 18px;">Expected Receptions</span>
                    <span class="result-value" id="expectedReceptions" style="font-size: 24px;">-</span>
                </div>
                <div class="result-item">
                    <span class="result-label" style="font-size: 18px;">Edge Score</span>
                    <span class="result-value final-score" id="finalScore">-</span>
                </div>
                <div class="score-interpretation" id="interpretation"></div>
            </div>

            <div class="bulk-results" id="bulkResults" style="display: none;">
                <div class="bulk-results-header">
                    <div class="results-count" id="resultsCount">0 players analyzed</div>
                    <button class="export-btn" id="exportBtn">Export CSV</button>
                </div>
                <div id="bulkResultsList"></div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.3/dist/umd/supabase.min.js"></script>

    <script>
        // Define Supabase constants globally, BEFORE any other logic
        const SUPABASE_URL = 'https://pyjtwdgapmbdgtpflzan.supabase.co';
        const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InB5anR3ZGdhcG1iZGd0cGZsemFuIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTExNTEzNTgsImV4cCI6MjA2NjcyNzM1OH0._Bt_XomEPAYRqC6zNgkNDwq66XFlpMoPbNMB6Eb4USo'; // Ensure this key is correct and not publicly exposed in a real app!
        
        // Use consistent season approach
        const PLAYER_STATS_SEASON = 2024; // Always use 2024 for player stats and defensive data
        const MATCHUPS_SEASON = 2025; // Use 2025 for weekly matchups to project future games

        let supabaseClient = null; 

        // **IMMEDIATE INITIALIZATION**
        try {
            if (typeof window.supabase !== 'undefined' && window.supabase.createClient) {
                supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
                console.log('Supabase client initialized successfully at script load.');
            } else {
                console.error('Supabase library not found or createClient is missing. Check script tag and network.');
                document.addEventListener('DOMContentLoaded', () => {
                    const mainContent = document.getElementById('mainContent');
                    if (mainContent) mainContent.style.display = 'block'; 
                    showError('FATAL: Supabase library failed to load. Check console for details.');
                });
            }
        } catch (error) {
            console.error('Error during Supabase client creation:', error);
            document.addEventListener('DOMContentLoaded', () => {
                const mainContent = document.getElementById('mainContent');
                if (mainContent) mainContent.style.display = 'block'; 
                showError('FATAL: Supabase client creation error: ' + error.message + '. Ensure URL/Key are correct.');
            });
        }

        // Other global variables
        let playerList = [];
        let selectedIndex = -1;
        let bulkResults = [];

        // Global team abbreviation map for consistency
        const teamAbbreviationMap = {
            'Arizona Cardinals': 'ARI', 'Atlanta Falcons': 'ATL', 'Baltimore Ravens': 'BAL',
            'Buffalo Bills': 'BUF', 'Carolina Panthers': 'CAR', 'Chicago Bears': 'CHI',
            'Cincinnati Bengals': 'CIN', 'Cleveland Browns': 'CLE', 'Dallas Cowboys': 'DAL',
            'Denver Broncos': 'DEN', 'Detroit Lions': 'DET', 'Green Bay Packers': 'GB',
            'Houston Texans': 'HOU', 'Indianapolis Colts': 'IND', 'Jacksonville Jaguars': 'JAX',
            'Kansas City Chiefs': 'KC', 'Las Vegas Raiders': 'LV', 'Los Angeles Chargers': 'LAC',
            'Los Angeles Rams': 'LAR', 'Miami Dolphins': 'MIA', 'Minnesota Vikings': 'MIN',
            'New England Patriots': 'NE', 'New Orleans Saints': 'NO', 'New York Giants': 'NYG',
            'New York Jets': 'NYJ', 'Philadelphia Eagles': 'PHI', 'Pittsburgh Steelers': 'PIT',
            'San Francisco 49ers': 'SF', 'Seattle Seahawks': 'SEA', 'Tampa Bay Buccaneers': 'TB',
            'Tennessee Titans': 'TEN', 'Washington Commanders': 'WAS'
        };

        // Utility function to get abbreviation from full name
        function getTeamAbbreviation(fullName) {
            // This function is crucial. It ensures consistency when querying DB.
            // It also handles cases where the input might already be an abbreviation or slightly off.
            for (const key in teamAbbreviationMap) {
                if (key.toLowerCase() === fullName.toLowerCase()) {
                    return teamAbbreviationMap[key]; // Found full name, return abbreviation
                }
                if (teamAbbreviationMap[key].toLowerCase() === fullName.toLowerCase()) {
                    return teamAbbreviationMap[key]; // Input was already a valid abbreviation
                }
            }
            return fullName.toUpperCase(); // Fallback: try to upper-case the input assuming it's an abbr
        }

        // Utility function to get full name from abbreviation
        function getFullTeamName(abbr) {
            for (const fullName in teamAbbreviationMap) {
                if (teamAbbreviationMap[fullName].toLowerCase() === abbr.toLowerCase()) {
                    return fullName;
                }
            }
            return abbr.toUpperCase(); // Fallback: return the abbreviation if no full name found
        }


        window.addEventListener('load', function() {
            setupPasswordHandling();
            setupModeToggle();
            setupAutocomplete(); 
            document.getElementById('calculateBtn').addEventListener('click', calculateProjection);
            document.getElementById('bulkCalculateBtn').addEventListener('click', runBulkAnalysis);
            document.getElementById('exportBtn').addEventListener('click', exportResults);

            if (!supabaseClient) {
                 showError('Supabase client is not available. API calls will likely fail.');
            }
        });

        function setupPasswordHandling() {
            const passwordOverlay = document.getElementById('passwordOverlay');
            const mainContent = document.getElementById('mainContent');
            const passwordInput = document.getElementById('passwordInput');
            const passwordSubmitBtn = document.getElementById('passwordSubmit');
            const passwordError = document.getElementById('passwordError');

            function checkPassword() {
                const correctPassword = 'KT81qd2023#'; // CHANGE THIS TO A SECURE, ENVIRONMENT VARIABLE IN PRODUCTION
                if (passwordInput.value === correctPassword) {
                    passwordOverlay.style.display = 'none';
                    mainContent.style.display = 'block';
                } else {
                    passwordError.style.display = 'block';
                    passwordInput.value = '';
                    setTimeout(() => {
                        passwordError.style.display = 'none';
                    }, 3000);
                }
            }

            passwordSubmitBtn.addEventListener('click', checkPassword);
            passwordInput.addEventListener('keypress', function(event) {
                if (event.key === 'Enter') {
                    checkPassword();
                }
            });

            passwordInput.focus();
        }

        function setupModeToggle() {
            const singleModeBtn = document.getElementById('singleModeBtn');
            const bulkModeBtn = document.getElementById('bulkModeBtn');
            const singleSection = document.getElementById('singleSection');
            const bulkSection = document.getElementById('bulkSection');
            const results = document.getElementById('results');
            const bulkResults = document.getElementById('bulkResults');

            singleModeBtn.addEventListener('click', () => {
                singleModeBtn.classList.add('active');
                bulkModeBtn.classList.remove('active');
                singleSection.style.display = 'block';
                bulkSection.style.display = 'none';
                results.style.display = 'none';
                bulkResults.style.display = 'none';
                hideError(); 
            });

            bulkModeBtn.addEventListener('click', () => {
                bulkModeBtn.classList.add('active');
                singleModeBtn.classList.remove('active');
                singleSection.style.display = 'none';
                bulkSection.style.display = 'block';
                results.style.display = 'none';
                bulkResults.style.display = 'none';
                hideError(); 
            });
        }

        async function runBulkAnalysis() {
            const week = document.getElementById('bulkWeek').value;
            const routesPerGame = 30; // Hardcoded for bulk analysis
            const gameFlow = 3;      // Hardcoded to Neutral for bulk analysis

            showBulkLoading(true);
            hideBulkResults();
            hideError();
            bulkResults = [];

            if (!supabaseClient) {
                showError('Supabase client not initialized. Cannot perform bulk analysis. Please refresh the page.');
                showBulkLoading(false);
                return; 
            }

            try {
                console.log('Starting bulk analysis...');
                
                // Test call to ensure the client is functional and the key is accepted
                const { error: testError } = await supabaseClient
                    .from('player_cover_stats') 
                    .select('player_name')     
                    .limit(1);

                if (testError) {
                    console.error('Supabase initial query failed:', testError);
                    throw new Error(`Supabase connection failed: ${testError.message}. Double-check your API key and table permissions.`);
                }
                console.log('Supabase client is making requests successfully (initial test passed).');
                updateProgress(5, `Connection verified. Fetching matchups for ${MATCHUPS_SEASON}...`);

                // STEP 1: Get matchups based on filters (using MATCHUPS_SEASON for weekly_matchups)
                // weekly_matchups contains 'home_team' and 'away_team' as FULL NAMES
                let matchupsQuery = supabaseClient
                    .from('weekly_matchups')
                    .select('*, home_team, away_team, week') // Explicitly select columns needed
                    .eq('season', MATCHUPS_SEASON); 

                if (week) {
                    matchupsQuery = matchupsQuery.eq('week', parseInt(week));
                }

                console.log(`Fetching matchups for season ${MATCHUPS_SEASON}...`);
                const { data: matchups, error: matchupError } = await matchupsQuery;

                if (matchupError) {
                    console.error(`Error fetching weekly_matchups for ${MATCHUPS_SEASON}:`, matchupError);
                    throw new Error(`Error fetching weekly matchups: ${matchupError.message}. Make sure the table exists and has data for ${MATCHUPS_SEASON}.`);
                }

                // DEBUGGING POINT 1
                console.log('Fetched Matchups (Season 2025):', matchups);

                if (!matchups || matchups.length === 0) {
                    console.warn(`No matchups found for the selected criteria (Season ${MATCHUPS_SEASON}, Week ${week || 'All'}).`);
                    showError(`No matchups found for the selected criteria (Season ${MATCHUPS_SEASON}, Week ${week || 'All'}). Please adjust filters.`);
                    showBulkLoading(false);
                    return;
                }

                console.log(`Found ${matchups.length} matchups for Season ${MATCHUPS_SEASON}.`);
                updateProgress(10, `Found ${matchups.length} matchups. Getting team list from matchups...`);

                // STEP 2: Extract all teams that have games AND CONVERT TO ABBREVIATIONS FOR PLAYER STATS JOIN
                const teamsWithGamesAbbr = new Set();
                matchups.forEach(matchup => {
                    teamsWithGamesAbbr.add(getTeamAbbreviation(matchup.home_team)); // Convert to abbr
                    teamsWithGamesAbbr.add(getTeamAbbreviation(matchup.away_team)); // Convert to abbr
                });
                
                // DEBUGGING POINT 2 (updated)
                console.log(`Teams with games (from 2025 matchups, converted to abbreviations):`, Array.from(teamsWithGamesAbbr));

                if (teamsWithGamesAbbr.size === 0) {
                    console.warn('No teams found in 2025 matchups or unable to convert to abbreviations. Check matchup data and teamAbbreviationMap.');
                    showError('No teams identified from 2025 matchups. Ensure data exists in weekly_matchups table and team names can be abbreviated.');
                    showBulkLoading(false);
                    return;
                }

                updateProgress(15, `Found ${teamsWithGamesAbbr.size} teams with games. Fetching players...`);

                // STEP 3: Get players ONLY from teams that have games in the matchups
                // player_cover_stats.team should store abbreviations
                console.log(`Fetching top players from Season ${PLAYER_STATS_SEASON} for teams with games: ${Array.from(teamsWithGamesAbbr).join(', ')}`);
                const { data: players, error: playerError } = await supabaseClient
                    .from('player_cover_stats')
                    .select('player_name, team, tprr_player')
                    .eq('season', PLAYER_STATS_SEASON)
                    .eq('coverage_type', 'Overall')
                    .in('team', Array.from(teamsWithGamesAbbr)) // THIS NOW USES ABBREVIATIONS
                    .gte('tprr_player', 0.08) // Minimum target rate
                    .order('tprr_player', { ascending: false })
                    .limit(200); // Get more players to ensure good coverage

                if (playerError) {
                    console.error(`Error fetching player_cover_stats for ${PLAYER_STATS_SEASON}:`, playerError);
                    throw new Error(`Error fetching player data: ${playerError.message}. Make sure the table exists and has data for ${PLAYER_STATS_SEASON}.`);
                }

                // DEBUGGING POINT 3 (updated)
                console.log(`Fetched Players (Season 2024, filtered by 2025 teams):`, players);

                if (!players || players.length === 0) {
                    console.warn(`No players found for teams with games (Season ${PLAYER_STATS_SEASON}, Teams: ${Array.from(teamsWithGamesAbbr).join(', ')}).`);
                    showError(`No players found for teams with games (Season ${PLAYER_STATS_SEASON}). Please check that player data exists for these teams and team names match abbreviations.`);
                    showBulkLoading(false);
                    return;
                }

                console.log(`Found ${players.length} players for Season ${PLAYER_STATS_SEASON} from teams with games.`);
                updateProgress(20, `Found ${players.length} players from teams with games. Creating matchup combinations...`);

                // STEP 4: Create player-matchup combinations
                const playerMatchupCombos = [];
                
                players.forEach(player => {
                    // Filter matchups where player's team (abbreviation) matches home or away team (converted to abbreviation)
                    const playerMatchups = matchups.filter(matchup => 
                        getTeamAbbreviation(matchup.home_team) === player.team || getTeamAbbreviation(matchup.away_team) === player.team
                    );
                    
                    playerMatchups.forEach(matchup => {
                        // Determine opponent's abbreviation
                        const opponentAbbr = getTeamAbbreviation(matchup.home_team) === player.team 
                                            ? getTeamAbbreviation(matchup.away_team) 
                                            : getTeamAbbreviation(matchup.home_team);
                        
                        playerMatchupCombos.push({
                            player_name: player.player_name, // Store player name directly
                            player_team_abbr: player.team, // Store player team abbreviation
                            tprr_player: player.tprr_player, // Store tprr for sorting
                            matchup_week: matchup.week, // Store matchup week
                            matchup_home_team_full: matchup.home_team, // Store full name for display later
                            matchup_away_team_full: matchup.away_team, // Store full name for display later
                            opponent_abbr: opponentAbbr // Opponent is now also an abbreviation
                        });
                    });
                });

                console.log(`Created ${playerMatchupCombos.length} player-matchup combinations.`);
                
                if (playerMatchupCombos.length === 0) {
                    showError('No valid player-matchup combinations found. This may indicate a mismatch between player team names and matchup team names after abbreviation.');
                    showBulkLoading(false);
                    return;
                }

                // Limit to top combinations for processing speed (prioritize highest TPRR players)
                const limitedCombos = playerMatchupCombos
                    .sort((a, b) => b.tprr_player - a.tprr_player)
                    .slice(0, 50); // Limit for efficiency

                console.log(`Processing top ${limitedCombos.length} player-matchup combinations...`);
                updateProgress(25, `Processing top ${limitedCombos.length} player-matchup combinations...`);

                // STEP 5: Process each player-matchup combination
                let processedCount = 0;
                for (let i = 0; i < limitedCombos.length; i++) {
                    const combo = limitedCombos[i];
                    const progressPercent = 25 + ((i + 1) / limitedCombos.length) * 70; // 25% to 95%
                    updateProgress(progressPercent, `Analyzing ${combo.player_name} vs ${combo.opponent_abbr} (Week ${combo.matchup_week})...`);

                    try {
                        const result = await calculatePlayerProjection(
                            combo.player_name,
                            combo.opponent_abbr, // Opponent is already abbreviation for API calls
                            gameFlow,        
                            routesPerGame,   
                            5.5 // Default betting line
                        );

                        if (result) {
                            // Enhance result with week and matchup info for display
                            const homeTeamDisplay = getFullTeamName(combo.player_team_abbr) === combo.matchup_home_team_full
                                                    ? combo.matchup_home_team_full
                                                    : combo.matchup_away_team_full;
                            const awayTeamDisplay = getFullTeamName(combo.player_team_abbr) === combo.matchup_home_team_full
                                                    ? combo.matchup_away_team_full
                                                    : combo.matchup_home_team_full;

                            bulkResults.push({
                                ...result,
                                week: combo.matchup_week,
                                matchup: `${homeTeamDisplay} vs ${awayTeamDisplay}` // Formatted matchup string
                            });
                            processedCount++;
                        }
                    } catch (error) {
                        console.warn(`Skipping projection for ${combo.player_name} vs ${combo.opponent_abbr} (Week ${combo.matchup_week}) due to error: ${error.message}`);
                    }
                }

                console.log(`Successfully processed ${processedCount} out of ${limitedCombos.length} combinations.`);
                updateProgress(95, 'Sorting and preparing results...');

                // Sort results by projected receptions (highest first)
                bulkResults.sort((a, b) => parseFloat(b.expectedReceptions) - parseFloat(a.expectedReceptions));

                // Limit to top 40 results for display (already done by slice earlier on combos if desired)
                // bulkResults = bulkResults.slice(0, 40); // Re-slice here if you want to limit after processing all

                updateProgress(100, 'Analysis complete!');
                
                if (bulkResults.length === 0) {
                    showError('Analysis completed but no valid projections were generated. This may indicate missing data for the selected teams/week.');
                } else {
                    displayBulkResults();
                }

            } catch (error) {
                console.error('Bulk analysis failed overall:', error);
                showError(error.message);
            } finally {
                showBulkLoading(false);
            }
        }

        async function calculatePlayerProjection(playerName, opponentTeamAbbr, gameFlow, routesPerGame, bettingLine) {
            // opponentTeamAbbr is already an abbreviation here, passed from bulk or converted from single player input
            try {
                // Get player's team and overall stats (using PLAYER_STATS_SEASON)
                const { data: playerData, error: playerError } = await supabaseClient
                    .from('player_cover_stats')
                    .select('team, tprr_player')
                    .eq('player_name', playerName)
                    .eq('season', PLAYER_STATS_SEASON) 
                    .eq('coverage_type', 'Overall')
                    .limit(1);

                if (playerError) {
                    console.error(`Error fetching player_cover_stats for ${playerName} (Season ${PLAYER_STATS_SEASON}):`, playerError);
                    throw new Error(`Player data error for ${playerName}: ${playerError.message}`);
                }

                if (!playerData || playerData.length === 0) {
                    console.warn(`Player "${playerName}" (Season ${PLAYER_STATS_SEASON}) not found or no overall stats. Using simple projection.`);
                    // Ensure simple projection returns all required fields for consistency
                    const result = calculateSimpleProjection(playerName, null, opponentTeamAbbr, 0.15, routesPerGame, gameFlow); 
                    return { 
                        ...result, 
                        bettingLine: bettingLine, 
                        playerTeam: 'N/A',
                        opponentTeam: getFullTeamName(opponentTeamAbbr) // Return full name for display
                    };
                }

                const playerTeamAbbr = playerData[0].team; // This will be the abbreviation
                const targetShare = (playerData[0].tprr_player * 100).toFixed(1);

                // Get opponent's coverage frequencies (using PLAYER_STATS_SEASON for defensive data)
                // defensive_coverages.team_name should store abbreviations
                const { data: coverageData, error: coverageError } = await supabaseClient
                    .from('defensive_coverages')
                    .select('*')
                    .eq('team_name', opponentTeamAbbr) // Use abbreviation here
                    .eq('season', PLAYER_STATS_SEASON) // Defensive data from PLAYER_STATS_SEASON (2024)
                    .limit(1);

                if (coverageError) {
                    console.error(`Error fetching defensive_coverages for ${opponentTeamAbbr} (Season ${PLAYER_STATS_SEASON}):`, coverageError);
                    throw new Error(`Defensive coverage data error for ${getFullTeamName(opponentTeamAbbr)}: ${coverageError.message}`);
                }

                if (!coverageData || coverageData.length === 0) {
                    console.warn(`No defensive coverage data for ${opponentTeamAbbr} (Season ${PLAYER_STATS_SEASON}), using defaults for calculation.`);
                    const result = calculateSimpleProjection(playerName, playerTeamAbbr, opponentTeamAbbr, targetShare, routesPerGame, gameFlow);
                    return { 
                        ...result, 
                        bettingLine: bettingLine,
                        opponentTeam: getFullTeamName(opponentTeamAbbr) // Return full name for display
                    };
                }

                const coverage = coverageData[0];
                
                const coverageTypes = [
                    { name: 'Man Coverage', pct: coverage.man_pct },
                    { name: 'Cover 2', pct: coverage.cover_2_pct },
                    { name: 'Cover 3', pct: coverage.cover_3_pct },
                    { name: 'Cover 4', pct: coverage.cover_4_pct },
                    { name: 'Cover 6', pct: coverage.cover_6_pct }
                ];

                // Get player stats for ALL coverage types (using PLAYER_STATS_SEASON)
                const { data: playerStats, error: statsError } = await supabaseClient
                    .from('player_cover_stats')
                    .select('coverage_type, tprr_player, separation_score')
                    .eq('player_name', playerName)
                    .eq('team', playerTeamAbbr) // playerTeam is abbreviation
                    .eq('season', PLAYER_STATS_SEASON) 
                    .in('coverage_type', ['Man Coverage', 'Cover 2', 'Cover 3', 'Cover 4', 'Cover 6']);

                if (statsError) {
                    console.error(`Error fetching detailed player_cover_stats for ${playerName} (Season ${PLAYER_STATS_SEASON}):`, statsError);
                    throw new Error(`Player coverage stats error for ${playerName}: ${statsError.message}`);
                }

                if (!playerStats || playerStats.length === 0) {
                    console.warn(`No detailed coverage stats found for ${playerName} (Season ${PLAYER_STATS_SEASON}), using simple projection.`);
                    const result = calculateSimpleProjection(playerName, playerTeamAbbr, opponentTeamAbbr, targetShare, routesPerGame, gameFlow);
                    return { 
                        ...result, 
                        bettingLine: bettingLine,
                        opponentTeam: getFullTeamName(opponentTeamAbbr) // Return full name for display
                    };
                }

                // Calculate weighted TPRR and separation scores
                let weightedTPRR = 0;
                let weightedSeparation = 0;
                let totalWeight = 0;

                coverageTypes.forEach(coverage => {
                    if (coverage.pct > 0) {
                        const playerStat = playerStats.find(s => s.coverage_type === coverage.name);
                        if (playerStat) {
                            const weight = coverage.pct / 100;
                            weightedTPRR += (playerStat.tprr_player * 100) * weight;
                            weightedSeparation += (playerStat.separation_score || 0.2) * weight; // Use default if score is missing
                            totalWeight += weight;
                        }
                    }
                });

                if (totalWeight === 0) {
                    console.warn(`No valid coverage data for ${playerName} from fetched stats to calculate weighted scores. Using simple projection.`);
                    const result = calculateSimpleProjection(playerName, playerTeamAbbr, opponentTeamAbbr, targetShare, routesPerGame, gameFlow);
                    return { 
                        ...result, 
                        bettingLine: bettingLine,
                        opponentTeam: getFullTeamName(opponentTeamAbbr) // Return full name for display
                    };
                }

                const stats = {
                    tprr_player: weightedTPRR / totalWeight,
                    separation_score: weightedSeparation / totalWeight
                };

                const mostFrequent = coverageTypes.filter(c => c.pct > 0).sort((a, b) => b.pct - a.pct)[0] || { name: 'Cover 3', pct: 30 };

                // Get defensive matchup stats (using PLAYER_STATS_SEASON)
                // defensive_matchups.defensive_team_name should store abbreviations
                const { data: defStats, error: defMatchupError } = await supabaseClient
                    .from('defensive_matchups')
                    .select('tprr_allowed, catch_rate_allowed')
                    .eq('defensive_team_name', opponentTeamAbbr) // Use abbreviation here
                    .eq('season', PLAYER_STATS_SEASON) 
                    .eq('coverage_type', mostFrequent.name)
                    .limit(1);
                
                if (defMatchupError) {
                    console.error(`Error fetching defensive_matchups for ${opponentTeamAbbr} (Season ${PLAYER_STATS_SEASON}):`, defMatchupError);
                }

                const defMatchup = defStats && defStats[0] ? defStats[0] : { tprr_allowed: 0.185, catch_rate_allowed: 63 };
                if (!defStats || defStats.length === 0) {
                    console.warn(`No specific defensive matchup stats for ${opponentTeamAbbr} in ${mostFrequent.name} coverage (Season ${PLAYER_STATS_SEASON}). Using default.`);
                }

                const result = calculateReceptionScore(
                    stats.tprr_player,
                    stats.separation_score,
                    parseFloat(targetShare),
                    routesPerGame,
                    gameFlow,
                    mostFrequent.pct,
                    defMatchup.tprr_allowed * 100, // Ensure percentage is correctly formatted
                    defMatchup.catch_rate_allowed
                );

                const projection = parseFloat(result.expectedReceptions);
                const edgeScore = projection - bettingLine;

                return {
                    playerName,
                    playerTeam: playerTeamAbbr, // Return abbreviation for internal logic
                    opponentTeam: getFullTeamName(opponentTeamAbbr), // Return full name for display
                    targetShare,
                    tprr: stats.tprr_player.toFixed(1),
                    sepScore: stats.separation_score.toFixed(3),
                    expectedReceptions: result.expectedReceptions,
                    bettingLine: bettingLine, 
                    edgeScore: edgeScore 
                };

            } catch (error) {
                console.error(`Full projection calculation failed for ${playerName} vs ${opponentTeamAbbr}:`, error);
                throw error; 
            }
        }

        function calculateSimpleProjection(playerName, playerTeam, opponentTeamAbbr, targetShare, routesPerGame, gameFlow) {
            const gameScriptMultiplier = 0.85 + (gameFlow * 0.075);
            const effectiveTPRR = parseFloat(targetShare) / 100; 
            const baseProjection = routesPerGame * effectiveTPRR * 0.65 * gameScriptMultiplier; 
            
            return {
                playerName,
                playerTeam: playerTeam || 'N/A', // Keep as abbreviation if available, or 'N/A'
                opponentTeam: getFullTeamName(opponentTeamAbbr), // Convert to full name for consistency in return
                targetShare: (effectiveTPRR * 100).toFixed(1),
                tprr: (effectiveTPRR * 100).toFixed(1),
                sepScore: "0.200", 
                expectedReceptions: baseProjection.toFixed(1),
                edgeScore: 0 // Default for simple projection
            };
        }

        function displayBulkResults() {
            const resultsCount = document.getElementById('resultsCount');
            const resultsList = document.getElementById('bulkResultsList');
            
            resultsCount.textContent = `Top ${bulkResults.length} players by projected receptions`; 
            
            if (bulkResults.length === 0) {
                resultsList.innerHTML = '<div class="loading">No players found matching criteria or no projections generated for this week.</div>';
                document.getElementById('bulkResults').style.display = 'block';
                return;
            }

            // Correctly reference properties from the 'result' object for display
            resultsList.innerHTML = bulkResults.map((result, index) => {
                // Ensure playerTeam and opponentTeam are displayed as abbreviations if that's what's stored
                const playerTeamDisplay = result.playerTeam || 'N/A';
                const opponentTeamDisplay = result.opponentTeam; // This is already the full name from calculatePlayerProjection
                
                return `
                    <div class="bulk-result-item">
                        <div class="result-header">
                            <div>
                                <div class="player-info">#${index + 1} ${result.playerName} (${playerTeamDisplay})</div>
                                <div class="matchup-info">Week ${result.week} - ${result.matchup}</div>
                            </div>
                            <div class="projection-score">
                                ${result.expectedReceptions} rec
                            </div>
                        </div>
                        <div class="result-details">
                            <div class="detail-item">
                                <div class="detail-label">Projection</div>
                                <div class="detail-value">${result.expectedReceptions}</div>
                            </div>
                            <div class="detail-item">
                                <div class="detail-label">Target Share</div>
                                <div class="detail-value">${result.targetShare}%</div>
                            </div>
                            <div class="detail-item">
                                <div class="detail-label">TPRR</div>
                                <div class="detail-value">${result.tprr}%</div>
                            </div>
                            <div class="detail-item">
                                <div class="detail-label">Separation</div>
                                <div class="detail-value">${result.sepScore}</div>
                            </div>
                            <div class="detail-item">
                                <div class="detail-label">Opponent</div>
                                <div class="detail-value">${opponentTeamDisplay}</div>
                            </div>
                            <div class="detail-item">
                                <div class="detail-label">Week</div>
                                <div class="detail-value">${result.week}</div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            document.getElementById('bulkResults').style.display = 'block';
        }

        function updateProgress(percentage, text) {
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            
            progressFill.style.width = percentage + '%';
            progressText.textContent = text;
        }

        function showBulkLoading(show) {
            document.getElementById('bulkProgress').style.display = show ? 'block' : 'none';
        }

        function hideBulkResults() {
            document.getElementById('bulkResults').style.display = 'none';
        }

        function exportResults() {
            if (bulkResults.length === 0) return;

            const csvContent = [
                ['Rank', 'Player', 'Team', 'Week', 'Matchup', 'Opponent', 'Projection', 'Target Share', 'TPRR', 'Separation'].join(','),
                ...bulkResults.map((result, index) => [
                    index + 1,
                    result.playerName,
                    result.playerTeam, // This will be the abbreviation now
                    result.week,
                    result.matchup,
                    result.opponentTeam, // This is the full name now
                    result.expectedReceptions,
                    result.targetShare + '%',
                    result.tprr + '%',
                    result.sepScore
                ].join(','))
            ].join('\n');

            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `nfl-top-projections-${new Date().toISOString().split('T')[0]}.csv`;
            a.click();
            window.URL.revokeObjectURL(url);
        }

        function normalizeTeamName(input) {
            // This function is primarily used by the single player autocomplete and input.
            // It tries to convert various inputs to a standardized full name.
            // This map has full name as key, abbreviation as value
            const reversedTeamMapping = {};
            for (const fullName in teamAbbreviationMap) {
                reversedTeamMapping[teamAbbreviationMap[fullName]] = fullName;
            }

            const lowerInput = input.trim().toLowerCase();
            
            // 1. Check if input is a known full name
            for (const fullName of Object.keys(teamAbbreviationMap)) {
                if (fullName.toLowerCase() === lowerInput) {
                    return fullName; // Return the exact full name from the map
                }
            }
            // 2. Check if input is a known abbreviation (and return its full name)
            for (const abbr in reversedTeamMapping) {
                if (abbr.toLowerCase() === lowerInput) {
                    return reversedTeamMapping[abbr];
                }
            }
            
            return input.trim(); // Return original if no match (could be partial or invalid)
        }


        async function calculateProjection() {
            const playerName = document.getElementById('playerName').value.trim();
            // opponentTeamFull will be the standardized full name (e.g., "Jacksonville Jaguars")
            const opponentTeamFull = normalizeTeamName(document.getElementById('opponentTeam').value); 
            // opponentTeamAbbr will be the abbreviation (e.g., "JAX")
            const opponentTeamAbbr = getTeamAbbreviation(opponentTeamFull); 
            
            const gameFlow = parseInt(document.getElementById('gameFlow').value);
            const routesPerGame = parseInt(document.getElementById('routesPerGame').value);
            const bettingLine = parseFloat(document.getElementById('bettingLine').value);

            if (!playerName || !opponentTeamFull || isNaN(routesPerGame) || isNaN(bettingLine)) { 
                showError('Please fill in all fields with valid numbers where required.');
                return;
            }
            
            if (!supabaseClient) {
                showError('Supabase client not initialized. Cannot calculate projection. Please refresh the page.');
                showLoading(false);
                return; 
            }

            showLoading(true);
            hideError();
            hideResults();

            try {
                // The `calculatePlayerProjection` function already handles fetching and returning
                // the data in a consistent format (playerTeam as abbr, opponentTeam as full name).
                const result = await calculatePlayerProjection(
                    playerName, 
                    opponentTeamAbbr, // Pass abbreviation for internal calculation
                    gameFlow, 
                    routesPerGame, 
                    bettingLine
                );

                // Now display the result directly from what `calculatePlayerProjection` returned
                const projection = parseFloat(result.expectedReceptions);
                const line = result.bettingLine;
                const edgeDifference = projection - line;
                const edgeScoreDisplay = (edgeDifference >= 0 ? '+' : '') + edgeDifference.toFixed(1);

                displayResults({
                    playerName: result.playerName,
                    playerTeam: result.playerTeam, // Abbreviation
                    opponentTeam: result.opponentTeam, // Full name
                    coverageType: "Weighted Analysis", // Or "Simple Projection" if that path was taken
                    coverageFreq: 100, // This might need to be more dynamic if you want precise freq breakdown for single player
                    coverageBreakdown: [], // You can populate this if needed for single player display
                    targetShare: result.targetShare,
                    tprr: result.tprr,
                    sepScore: result.sepScore,
                    expectedReceptions: result.expectedReceptions,
                    receptionScore: result.finalScore, // This is the overall model score if calculateReceptionScore returns it
                    bettingLine: bettingLine,
                    edgeScore: edgeScoreDisplay // Pass edgeScore explicitly for display
                });

            } catch (error) {
                console.error('Projection calculation failed:', error);
                showError(error.message);
            } finally {
                showLoading(false);
            }
        }

        function calculateReceptionScore(weightedTPRR, weightedSeparation, targetShare, routesPerGame, gameFlow, primaryCoverageFreq, defTPRR, defCatchRate) {
            // === ADVANCED STATISTICAL MODEL ===
            
            // 1. EFFICIENCY COMPONENT (40% weight)
            const tprrZScore = (weightedTPRR - 18.5) / 5.0;
            const efficiencyScore = Math.max(0, 50 + (tprrZScore * 15));
            
            // 2. VOLUME COMPONENT (30% weight)
            const totalOpportunity = (targetShare / 100) * routesPerGame;
            const volumeScore = Math.min(totalOpportunity * 2.5, 100);
            
            // 3. SEPARATION COMPONENT (15% weight) 
            const separationZScore = (weightedSeparation - 0.20) / 0.05;
            const separationScore = Math.max(0, 50 + (separationZScore * 12));
            
            // 4. DEFENSIVE MATCHUP COMPONENT (15% weight)
            const defTPRRZScore = (defTPRR - 18.5) / 3.0;
            const defCatchZScore = (defCatchRate - 63.0) / 5.0;
            const matchupScore = 50 + (defTPRRZScore * 10) + (defCatchZScore * 8);
            
            // 5. GAME SCRIPT MULTIPLIER
            const gameScriptMultiplier = 0.85 + (gameFlow * 0.075);
            
            // === COMBINE COMPONENTS ===
            const baseScore = (efficiencyScore * 0.40) + 
                            (volumeScore * 0.30) + 
                            (separationScore * 0.15) + 
                            (matchupScore * 0.15);
            
            const finalScore = Math.min(baseScore * gameScriptMultiplier, 100);
            
            // === EXPECTED RECEPTIONS CALCULATION ===
            const baseReceptions = routesPerGame * (weightedTPRR / 100) * (defCatchRate / 100) * gameScriptMultiplier;
            
            let confidenceFactor = 1.0;
            if (finalScore >= 80) confidenceFactor = 1.15;
            else if (finalScore >= 65) confidenceFactor = 1.05;
            else if (finalScore >= 35) confidenceFactor = 1.0;
            else if (finalScore >= 20) confidenceFactor = 0.95;
            else confidenceFactor = 0.85;
            
            const expectedReceptions = (baseReceptions * confidenceFactor).toFixed(1);
            
            return {
                finalScore: finalScore.toFixed(1), // Changed to return finalScore
                expectedReceptions
            };
        }

        function displayResults(data) {
            let coverageInfoHtml = `<h4>Coverage Analysis</h4>`;
            if (data.coverageBreakdown && data.coverageBreakdown.length > 0) {
                coverageInfoHtml += `<p>Defensive coverages faced by ${data.opponentTeam}:</p><ul>`;
                data.coverageBreakdown.forEach(item => {
                    coverageInfoHtml += `<li>${item.name}: ${item.frequency}% (Player TPRR: ${item.playerTPRR}%)</li>`;
                });
                coverageInfoHtml += `</ul>`;
            } else {
                // Ensure this message is dynamic based on why simple projection was used
                coverageInfoHtml += `<p>${data.coverageType} used due to missing data for player or defense. Results may be less accurate.</p>`;
            }
            document.getElementById('coverageInfo').innerHTML = coverageInfoHtml;
            
            const projection = parseFloat(data.expectedReceptions);
            const line = data.bettingLine;
            const edgeDifference = projection - line;
            const edgeScoreDisplay = (edgeDifference >= 0 ? '+' : '') + edgeDifference.toFixed(1);
            
            document.getElementById('playerDisplay').textContent = `${data.playerName} (${data.playerTeam})`; // Shows abbr
            document.getElementById('defenseDisplay').textContent = data.opponentTeam; // Shows full name
            document.getElementById('targetShare').textContent = `${data.targetShare}%`;
            document.getElementById('tprrDisplay').textContent = `${data.tprr}%`;
            document.getElementById('sepScoreDisplay').textContent = data.sepScore;
            document.getElementById('expectedReceptions').textContent = data.expectedReceptions;
            document.getElementById('finalScore').textContent = edgeScoreDisplay; // Displaying calculated edge score
            // If you want to show the underlying model score too, you can add another line
            // document.getElementById('modelScore').textContent = data.receptionScore; 

            let interpretation = '';
            let interpretClass = '';

            if (edgeDifference >= 1.5) {
                interpretation = 'GOOD EDGE - Significant positive value';
                interpretClass = 'score-high';
            } else if (edgeDifference >= 0.5) { 
                interpretation = 'MODERATE EDGE - Positive value, consider';
                interpretClass = 'score-medium';
            } else if (edgeDifference >= 0) {
                interpretation = 'SLIGHT EDGE - Proceed with caution';
                interpretClass = 'score-medium';
            }
            else if (edgeDifference > -0.5) { 
                interpretation = 'NEUTRAL EDGE - Minimal difference';
                interpretClass = 'score-medium';
            }
            else {
                interpretation = 'POOR EDGE - Negative value, avoid bet';
                interpretClass = 'score-low';
            }

            const interpretDiv = document.getElementById('interpretation');
            interpretDiv.textContent = interpretation;
            interpretDiv.className = 'score-interpretation ' + interpretClass;

            document.getElementById('results').style.display = 'block';
        }

        function showLoading(show) {
            document.getElementById('loadingDiv').style.display = show ? 'block' : 'none';
        }

        function showError(message) {
            const errorDiv = document.getElementById('errorDiv');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        function hideError() {
            document.getElementById('errorDiv').style.display = 'none';
        }

        function hideResults() {
            document.getElementById('results').style.display = 'none';
        }

        // Autocomplete functionality
        async function setupAutocomplete() {
            await loadPlayerNames(); 
            setupPlayerAutocomplete();
            setupTeamAutocomplete();
        }

        async function loadPlayerNames() {
            if (!supabaseClient) {
                console.warn('Supabase client not initialized when attempting to load player names for autocomplete.');
                return; 
            }
            try {
                const { data, error } = await supabaseClient
                    .from('player_cover_stats')
                    .select('player_name')
                    .eq('season', PLAYER_STATS_SEASON) 
                    .eq('coverage_type', 'Overall');
                
                if (data) {
                    const uniqueNames = [...new Set(data.map(player => player.player_name))];
                    playerList = uniqueNames.sort();
                    console.log('Player names loaded for autocomplete.');
                }
                if (error) {
                    console.error('Error loading player names for autocomplete:', error);
                }
            } catch (error) {
                console.error('Error loading player names (catch block):', error);
            }
        }

        function setupPlayerAutocomplete() {
            const input = document.getElementById('playerName');
            const suggestions = document.getElementById('playerSuggestions');
            
            input.addEventListener('input', function() {
                const value = this.value.toLowerCase();
                selectedIndex = -1;
                
                if (value.length < 2) {
                    suggestions.style.display = 'none';
                    return;
                }
                
                const filtered = playerList.filter(player => 
                    player.toLowerCase().includes(value)
                ).slice(0, 8);
                
                if (filtered.length > 0) {
                    suggestions.innerHTML = filtered.map(player => 
                        `<div class="autocomplete-suggestion">${player}</div>`
                    ).join('');
                    suggestions.style.display = 'block';
                    
                    suggestions.querySelectorAll('.autocomplete-suggestion').forEach((item, index) => {
                        item.addEventListener('click', () => {
                            input.value = item.textContent;
                            suggestions.style.display = 'none';
                        });
                    });
                } else {
                    suggestions.style.display = 'none';
                }
            });
            
            input.addEventListener('keydown', function(e) {
                const items = suggestions.querySelectorAll('.autocomplete-suggestion');
                
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    selectedIndex = Math.min(selectedIndex + 1, items.length - 1);
                    updateSelection(items);
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    selectedIndex = Math.max(selectedIndex - 1, -1);
                    updateSelection(items);
                } else if (e.key === 'Enter' && selectedIndex >= 0) {
                    e.preventDefault();
                    input.value = items[selectedIndex].textContent;
                    suggestions.style.display = 'none';
                } else if (e.key === 'Escape') {
                    suggestions.style.display = 'none';
                }
            });
            
            document.addEventListener('click', function(e) {
                if (!input.contains(e.target) && !suggestions.contains(e.target)) {
                    suggestions.style.display = 'none';
                }
            });
        }

        function setupTeamAutocomplete() {
            const input = document.getElementById('opponentTeam');
            const suggestions = document.getElementById('teamSuggestions');
            
            const teams = [
                'Arizona Cardinals', 'Atlanta Falcons', 'Baltimore Ravens', 'Buffalo Bills',
                'Carolina Panthers', 'Chicago Bears', 'Cincinnati Bengals', 'Cleveland Browns',
                'Dallas Cowboys', 'Denver Broncos', 'Detroit Lions', 'Green Bay Packers',
                'Houston Texans', 'Indianapolis Colts', 'Jacksonville Jaguars', 'Kansas City Chiefs',
                'Las Vegas Raiders', 'Los Angeles Chargers', 'Los Angeles Rams', 'Miami Dolphins',
                'Minnesota Vikings', 'New England Patriots', 'New Orleans Saints', 'New York Giants',
                'New York Jets', 'Philadelphia Eagles', 'Pittsburgh Steelers', 'San Francisco 49ers',
                'Seattle Seahawks', 'Tampa Bay Buccaneers', 'Tennessee Titans', 'Washington Commanders'
            ];
            
            input.addEventListener('input', function() {
                const value = this.value.toLowerCase();
                selectedIndex = -1;
                
                if (value.length < 1) {
                    suggestions.style.display = 'none';
                    return;
                }
                
                const filtered = teams.filter(team => 
                    team.toLowerCase().includes(value) || 
                    (teamAbbreviationMap[team] && teamAbbreviationMap[team].toLowerCase().includes(value)) // Check for abbr match
                ).slice(0, 8);
                
                if (filtered.length > 0) {
                    suggestions.innerHTML = filtered.map(team => 
                        `<div class="autocomplete-suggestion">${team}</div>`
                    ).join('');
                    suggestions.style.display = 'block';
                    
                    suggestions.querySelectorAll('.autocomplete-suggestion').forEach((item, index) => {
                        item.addEventListener('click', () => {
                            input.value = item.textContent;
                            suggestions.style.display = 'none';
                        });
                    });
                } else {
                    suggestions.style.display = 'none';
                }
            });
            
            input.addEventListener('keydown', function(e) {
                const items = suggestions.querySelectorAll('.autocomplete-suggestion');
                
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    selectedIndex = Math.min(selectedIndex + 1, items.length - 1);
                    updateSelection(items);
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    selectedIndex = Math.max(selectedIndex - 1, -1);
                    updateSelection(items);
                } else if (e.key === 'Enter' && selectedIndex >= 0) {
                    e.preventDefault();
                    input.value = items[selectedIndex].textContent;
                    suggestions.style.display = 'none';
                } else if (e.key === 'Escape') {
                    suggestions.style.display = 'none';
                }
            });
            
            document.addEventListener('click', function(e) {
                if (!input.contains(e.target) && !suggestions.contains(e.target)) {
                    suggestions.style.display = 'none';
                }
            });
        }

        function updateSelection(items) {
            items.forEach((item, index) => {
                if (index === selectedIndex) {
                    item.classList.add('selected');
                } else {
                    item.classList.remove('selected');
                }
            });
        }
    </script>
</body>
</html>
