<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clear Edge Sports - NFL Model</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: #111a29;
            color: white;
            padding: 20px;
            line-height: 1.6;
            position: relative;
            overflow-x: hidden;
            min-height: 100vh;
        }
        
        /* Enhanced animated background - matching business site */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                linear-gradient(135deg, #111a29 0%, #1a2332 30%, #0f1419 70%, #111a29 100%);
            z-index: -2;
        }

        body::after {
            content: '';
            position: fixed;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: 
                conic-gradient(from 0deg at 25% 25%, transparent 0deg, rgba(59, 130, 246, 0.08) 45deg, transparent 90deg),
                conic-gradient(from 180deg at 75% 75%, transparent 0deg, rgba(255, 215, 0, 0.08) 45deg, transparent 90deg),
                conic-gradient(from 90deg at 50% 50%, transparent 0deg, rgba(139, 69, 19, 0.05) 30deg, transparent 60deg);
            animation: rotate 25s linear infinite;
            z-index: -1;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .password-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        
        .password-container {
            background: rgba(255, 255, 255, 0.03);
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 20px;
            padding: 50px;
            text-align: center;
            max-width: 450px;
            width: 100%;
            backdrop-filter: blur(15px);
            position: relative;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.3);
        }

        .password-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, #FFD700, transparent);
            animation: shimmer 3s ease-in-out infinite alternate;
        }

        @keyframes shimmer {
            0% { opacity: 0.3; }
            100% { opacity: 1; }
        }
        
        .password-title {
            font-size: 28px;
            font-weight: 900;
            color: #FFD700;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 3px;
            text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.5);
        }

        .password-subtitle {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 30px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .password-input {
            width: 100%;
            padding: 18px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 12px;
            color: white;
            font-size: 18px;
            text-align: center;
            letter-spacing: 2px;
            transition: all 0.3s ease;
            margin: 20px 0;
            outline: none;
            font-weight: 600;
        }

        .password-input:focus {
            border-color: #FFD700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
            transform: scale(1.02);
        }

        .password-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
            font-weight: 400;
        }
        
        .password-submit {
            width: 100%;
            padding: 15px 40px;
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            color: #111a29;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 800;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 5px 20px rgba(255, 215, 0, 0.3);
        }

        .password-submit:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 8px 25px rgba(255, 215, 0, 0.5);
        }
        
        .password-error {
            color: #ff4444;
            font-size: 14px;
            margin-top: 15px;
            display: none;
            font-weight: 600;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3);
        }
        
        .main-content {
            display: none;
            position: relative;
            z-index: 1;
        }
        
        .container {
            max-width: 1000px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            color: white;
            margin-bottom: 40px;
            font-size: 3rem;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 3px;
            text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.5);
        }

        .model-subtitle {
            text-align: center;
            color: #FFD700;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: 700;
            margin-bottom: 40px;
        }

        .calculation-mode {
            display: flex;
            justify-content: center;
            margin-bottom: 30px;
        }

        .mode-btn {
            padding: 12px 24px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 12px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 0 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .mode-btn.active {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            color: #111a29;
            border-color: #FFD700;
        }

        .mode-btn:hover {
            border-color: #FFD700;
            transform: translateY(-2px);
        }
        
        .input-card {
            background: rgba(255, 255, 255, 0.03);
            border: 2px solid rgba(255, 215, 0, 0.15);
            border-radius: 20px;
            padding: 30px;
            backdrop-filter: blur(15px);
            position: relative;
            overflow: hidden;
            margin-bottom: 30px;
        }

        .input-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, #FFD700, transparent);
            animation: shimmer 3s ease-in-out infinite alternate;
        }

        .bulk-section {
            display: none;
        }

        .bulk-filters {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .input-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            color: #FFD700;
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        input[type="text"], input[type="number"], select {
            width: 100%;
            padding: 12px 15px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 8px;
            color: white;
            font-size: 16px;
            transition: all 0.3s ease;
            outline: none;
        }
        
        input:focus, select:focus {
            border-color: #FFD700;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.2);
            background: rgba(255, 255, 255, 0.15);
        }

        input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }
        
        .calculate-btn {
            width: 100%;
            padding: 18px;
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            color: #111a29;
            border: none;
            border-radius: 12px;
            font-size: 18px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 20px;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 5px 20px rgba(255, 215, 0, 0.3);
        }
        
        .calculate-btn:hover {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 8px 25px rgba(255, 215, 0, 0.5);
        }
        
        .calculate-btn:active {
            transform: translateY(0);
        }

        .bulk-results {
            background: rgba(255, 255, 255, 0.03);
            border: 2px solid rgba(255, 215, 0, 0.15);
            border-radius: 20px;
            padding: 30px;
            backdrop-filter: blur(15px);
            position: relative;
            overflow: hidden;
            margin-top: 30px;
        }

        .bulk-results::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, #FFD700, transparent);
            animation: shimmer 3s ease-in-out infinite alternate;
        }

        .bulk-results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid rgba(255, 215, 0, 0.3);
        }

        .results-count {
            color: #FFD700;
            font-size: 16px;
            font-weight: 600;
        }

        .export-btn {
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.1);
            color: #FFD700;
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 8px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }

        .export-btn:hover {
            background: rgba(255, 215, 0, 0.1);
            border-color: #FFD700;
        }

        .bulk-result-item {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 215, 0, 0.2);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
            transition: all 0.3s ease;
        }

        .bulk-result-item:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 215, 0, 0.4);
            transform: translateY(-2px);
        }

        .result-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .player-info {
            font-size: 16px;
            font-weight: 700;
            color: white;
        }

        .matchup-info {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.7);
        }

        .projection-score {
            font-size: 20px;
            font-weight: 800;
            padding: 5px 12px;
            border-radius: 8px;
            background: rgba(255, 215, 0, 0.2);
            color: #FFD700;
            border: 1px solid rgba(255, 215, 0, 0.3);
        }

        .result-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin-top: 10px;
            font-size: 12px;
        }

        .detail-item {
            text-align: center;
        }

        .detail-label {
            color: #FFD700;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 3px;
        }

        .detail-value {
            color: rgba(255, 255, 255, 0.9);
            font-weight: 600;
        }
        
        .results {
            background: rgba(255, 255, 255, 0.03);
            border: 2px solid rgba(255, 215, 0, 0.15);
            border-radius: 20px;
            padding: 30px;
            backdrop-filter: blur(15px);
            position: relative;
            overflow: hidden;
        }

        .results::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, #FFD700, transparent);
            animation: shimmer 3s ease-in-out infinite alternate;
        }
        
        .result-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 0;
            border-bottom: 1px solid rgba(255, 215, 0, 0.2);
        }
        
        .result-item:last-child {
            border-bottom: none;
        }
        
        .result-label {
            color: #FFD700;
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .result-value {
            font-size: 18px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.9);
        }
        
        .final-score {
            font-size: 32px !important;
            color: #FFD700 !important;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
        }
        
        .score-interpretation {
            margin-top: 20px;
            padding: 15px;
            border-radius: 12px;
            text-align: center;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .score-high {
            background: rgba(34, 197, 94, 0.1);
            border: 2px solid rgba(34, 197, 94, 0.3);
            color: #22c55e;
        }
        
        .score-medium {
            background: rgba(255, 215, 0, 0.1);
            border: 2px solid rgba(255, 215, 0, 0.3);
            color: #FFD700;
        }
        
        .score-low {
            background: rgba(239, 68, 68, 0.1);
            border: 2px solid rgba(239, 68, 68, 0.3);
            color: #ef4444;
        }
        
        .info-text {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
            margin-top: 5px;
            font-style: italic;
        }

        .autocomplete-container {
            position: relative;
        }

        .autocomplete-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: rgba(17, 26, 41, 0.95);
            backdrop-filter: blur(15px);
            border: 2px solid rgba(255, 215, 0, 0.5);
            border-top: none;
            border-radius: 0 0 8px 8px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5);
        }

        .autocomplete-suggestion {
            padding: 12px 15px;
            color: rgba(255, 255, 255, 0.9);
            cursor: pointer;
            transition: all 0.2s ease;
            border-bottom: 1px solid rgba(255, 215, 0, 0.1);
        }

        .autocomplete-suggestion:hover,
        .autocomplete-suggestion.selected {
            background: rgba(255, 215, 0, 0.2);
            color: #FFD700;
        }

        .autocomplete-suggestion:last-child {
            border-bottom: none;
        }

        .autocomplete-suggestions::-webkit-scrollbar {
            width: 6px;
        }

        .autocomplete-suggestions::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
        }

        .autocomplete-suggestions::-webkit-scrollbar-thumb {
            background: rgba(255, 215, 0, 0.5);
            border-radius: 3px;
        }
        
        .game-context-scale {
            margin-top: 10px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
        }
        
        .loading {
            text-align: center;
            color: #FFD700;
            padding: 20px;
            font-weight: 600;
        }
        
        .error {
            text-align: center;
            color: #ef4444;
            padding: 20px;
            font-weight: 600;
        }
        
        .coverage-info {
            background: rgba(255, 215, 0, 0.1);
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .coverage-info h4 {
            color: #FFD700;
            margin-bottom: 5px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .coverage-info p {
            color: rgba(255, 255, 255, 0.8);
            font-weight: 500;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #FFD700, #FFA500);
            width: 0%;
            transition: width 0.3s ease;
        }

        .progress-text {
            text-align: center;
            color: #FFD700;
            font-size: 14px;
            font-weight: 600;
            margin-top: 5px;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            h1 {
                font-size: 2.5rem;
            }

            .password-container {
                padding: 30px 20px;
            }

            .password-title {
                font-size: 24px;
            }
            
            .input-card, .results, .bulk-results {
                padding: 20px;
            }

            .calculation-mode {
                flex-direction: column;
                align-items: center;
            }

            .mode-btn {
                margin: 5px 0;
                width: 200px;
            }

            .bulk-filters {
                grid-template-columns: 1fr;
            }

            .result-details {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="password-overlay" id="passwordOverlay">
        <div class="password-container">
            <h2 class="password-title">Clear Edge</h2>
            <p class="password-subtitle">NFL Model Access</p>
            <input type="password" class="password-input" id="passwordInput" placeholder="Enter Password" autocomplete="off">
            <button class="password-submit" id="passwordSubmit">ACCESS MODEL</button>
            <div class="password-error" id="passwordError">Incorrect password. Please try again.</div>
        </div>
    </div>

    <div class="main-content" id="mainContent">
        <div class="container">
            <h1>NFL Model</h1>
            <p class="model-subtitle">Advanced Analytics & Predictions</p>
            
            <div class="calculation-mode">
                <button class="mode-btn active" id="singleModeBtn">Single Player</button>
                <button class="mode-btn" id="bulkModeBtn">Bulk Analysis</button>
            </div>

            <div class="input-card" id="singleSection">
                <div class="input-group">
                    <label for="playerName">Player Name</label>
                    <div class="autocomplete-container">
                        <input type="text" id="playerName" placeholder="e.g., Ja'Marr Chase" autocomplete="off">
                        <div class="autocomplete-suggestions" id="playerSuggestions"></div>
                    </div>
                </div>
                
                <div class="input-group">
                    <label for="opponentTeam">Opponent Team</label>
                    <div class="autocomplete-container">
                        <input type="text" id="opponentTeam" placeholder="e.g., Jacksonville Jaguars or JAX" autocomplete="off">
                        <div class="autocomplete-suggestions" id="teamSuggestions"></div>
                    </div>
                </div>
                
                <div class="input-group">
                    <label for="gameFlow">Expected Game Flow</label>
                    <select id="gameFlow">
                        <option value="3">Neutral (Even matchup)</option>
                        <option value="1">Heavy Favorite (14+ point favorite)</option>
                        <option value="2">Slight Favorite (7-13 point favorite)</option>
                        <option value="4">Slight Underdog (7-13 point underdog)</option>
                        <option value="5">Heavy Underdog (14+ point underdog)</option>
                    </select>
                    <div class="info-text">How the game script is expected to play out</div>
                </div>
                
                <div class="input-group">
                    <label for="routesPerGame">Routes Per Game</label>
                    <input type="number" id="routesPerGame" placeholder="e.g., 35" min="0" max="60" value="35">
                    <div class="info-text">Average routes run per game by the player</div>
                </div>
                
                <div class="input-group">
                    <label for="bettingLine">Betting Line (Receptions)</label>
                    <input type="number" id="bettingLine" placeholder="e.g., 5.5" step="0.5" min="0" max="15">
                    <div class="info-text">Over/Under line for player receptions</div>
                </div>
                
                <button class="calculate-btn" id="calculateBtn">Calculate Reception Projection</button>
            </div>

            <div class="input-card bulk-section" id="bulkSection">
                <div class="bulk-filters">
                    <div class="input-group">
                        <label for="bulkWeek">Week</label>
                        <select id="bulkWeek">
                            <option value="">All Weeks</option>
                            <option value="1">Week 1</option>
                            <option value="2">Week 2</option>
                            <option value="3">Week 3</option>
                            <option value="4">Week 4</option>
                            <option value="5">Week 5</option>
                            <option value="6">Week 6</option>
                            <option value="7">Week 7</option>
                            <option value="8">Week 8</option>
                            <option value="9">Week 9</option>
                            <option value="10">Week 10</option>
                            <option value="11">Week 11</option>
                            <option value="12">Week 12</option>
                            <option value="13">Week 13</option>
                            <option value="14">Week 14</option>
                            <option value="15">Week 15</option>
                            <option value="16">Week 16</option>
                            <option value="17">Week 17</option>
                            <option value="18">Week 18</option>
                        </select>
                    </div>
                </div>
                
                <button class="calculate-btn" id="bulkCalculateBtn">Run Bulk Analysis</button>
                
                <div id="bulkProgress" style="display: none;">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                    <div class="progress-text" id="progressText">Analyzing players...</div>
                </div>
            </div>
            
            <div id="loadingDiv" class="loading" style="display: none;">
                Calculating projection...
            </div>
            
            <div id="errorDiv" class="error" style="display: none;"></div>
            
            <div class="results" id="results" style="display: none;">
                <div id="coverageInfo" class="coverage-info"></div>
                
                <div class="result-item">
                    <span class="result-label">Player</span>
                    <span class="result-value" id="playerDisplay">-</span>
                </div>
                <div class="result-item">
                    <span class="result-label">vs Defense</span>
                    <span class="result-value" id="defenseDisplay">-</span>
                </div>
                <div class="result-item">
                    <span class="result-label">Target Share</span>
                    <span class="result-value" id="targetShare">-</span>
                </div>
                <div class="result-item">
                    <span class="result-label">Weighted TPRR</span>
                    <span class="result-value" id="tprrDisplay">-</span>
                </div>
                <div class="result-item">
                    <span class="result-label">Separation Score</span>
                    <span class="result-value" id="sepScoreDisplay">-</span>
                </div>
                <div class="result-item" style="margin-top: 10px; padding-top: 20px; border-top: 2px solid #FFD700;">
                    <span class="result-label" style="font-size: 18px;">Expected Receptions</span>
                    <span class="result-value" id="expectedReceptions" style="font-size: 24px;">-</span>
                </div>
                <div class="result-item">
                    <span class="result-label" style="font-size: 18px;">Edge Score</span>
                    <span class="result-value final-score" id="finalScore">-</span>
                </div>
                <div class="score-interpretation" id="interpretation"></div>
            </div>

            <div class="bulk-results" id="bulkResults" style="display: none;">
                <div class="bulk-results-header">
                    <div class="results-count" id="resultsCount">0 players analyzed</div>
                    <button class="export-btn" id="exportBtn">Export CSV</button>
                </div>
                <div id="bulkResultsList"></div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.3/dist/umd/supabase.min.js"></script>

    <script>
        // Define Supabase constants globally, BEFORE any other logic
        const SUPABASE_URL = 'https://pyjtwdgapmbdgtpflzan.supabase.co';
        const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InB5anR3ZGdhcG1iZGd0cGZsemFuIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTExNTEzNTgsImV4cCI6MjA2NjcyNzM1OH0._Bt_XomEPAYRqC6zNgkNDwq66XFlpMoPbNMB6Eb4USo';
        
        // Use consistent season approach
        const PLAYER_STATS_SEASON = 2024; // Always use 2024 for player stats and defensive data
        const MATCHUPS_SEASON = 2025; // Use 2025 for weekly matchups to project future games

        let supabaseClient = null; 

        // **IMMEDIATE INITIALIZATION**
        try {
            if (typeof window.supabase !== 'undefined' && window.supabase.createClient) {
                supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
                console.log('Supabase client initialized successfully at script load.');
            } else {
                console.error('Supabase library not found or createClient is missing. Check script tag and network.');
                document.addEventListener('DOMContentLoaded', () => {
                    const mainContent = document.getElementById('mainContent');
                    if (mainContent) mainContent.style.display = 'block'; 
                    showError('FATAL: Supabase library failed to load. Check console for details.');
                });
            }
        } catch (error) {
            console.error('Error during Supabase client creation:', error);
            document.addEventListener('DOMContentLoaded', () => {
                const mainContent = document.getElementById('mainContent');
                if (mainContent) mainContent.style.display = 'block'; 
                showError('FATAL: Supabase client creation error: ' + error.message + '. Ensure URL/Key are correct.');
            });
        }

        // Other global variables
        let playerList = [];
        let selectedIndex = -1;
        let bulkResults = [];

        // Global team abbreviation map for consistency
        const teamAbbreviationMap = {
            'Arizona Cardinals': 'ARI', 'Atlanta Falcons': 'ATL', 'Baltimore Ravens': 'BAL',
            'Buffalo Bills': 'BUF', 'Carolina Panthers': 'CAR', 'Chicago Bears': 'CHI',
            'Cincinnati Bengals': 'CIN', 'Cleveland Browns': 'CLE', 'Dallas Cowboys': 'DAL',
            'Denver Broncos': 'DEN', 'Detroit Lions': 'DET', 'Green Bay Packers': 'GB',
            'Houston Texans': 'HOU', 'Indianapolis Colts': 'IND', 'Jacksonville Jaguars': 'JAX',
            'Kansas City Chiefs': 'KC', 'Las Vegas Raiders': 'LV', 'Los Angeles Chargers': 'LAC',
            'Los Angeles Rams': 'LAR', 'Miami Dolphins': 'MIA', 'Minnesota Vikings': 'MIN',
            'New England Patriots': 'NE', 'New Orleans Saints': 'NO', 'New York Giants': 'NYG',
            'New York Jets': 'NYJ', 'Philadelphia Eagles': 'PHI', 'Pittsburgh Steelers': 'PIT',
            'San Francisco 49ers': 'SF', 'Seattle Seahawks': 'SEA', 'Tampa Bay Buccaneers': 'TB',
            'Tennessee Titans': 'TEN', 'Washington Commanders': 'WAS'
        };

        // Utility function to get abbreviation from full name
        function getTeamAbbreviation(fullName) {
            // Trim whitespace and handle potential case differences if necessary
            // For now, assuming full name from DB will match map keys exactly
            return teamAbbreviationMap[fullName] || fullName; 
        }

        window.addEventListener('load', function() {
            setupPasswordHandling();
            setupModeToggle();
            setupAutocomplete(); 
            document.getElementById('calculateBtn').addEventListener('click', calculateProjection);
            document.getElementById('bulkCalculateBtn').addEventListener('click', runBulkAnalysis);
            document.getElementById('exportBtn').addEventListener('click', exportResults);

            if (!supabaseClient) {
                 showError('Supabase client is not available. API calls will likely fail.');
            }
        });

        function setupPasswordHandling() {
            const passwordOverlay = document.getElementById('passwordOverlay');
            const mainContent = document.getElementById('mainContent');
            const passwordInput = document.getElementById('passwordInput');
            const passwordSubmitBtn = document.getElementById('passwordSubmit');
            const passwordError = document.getElementById('passwordError');

            function checkPassword() {
                const correctPassword = 'KT81qd2023#';
                if (passwordInput.value === correctPassword) {
                    passwordOverlay.style.display = 'none';
                    mainContent.style.display = 'block';
                } else {
                    passwordError.style.display = 'block';
                    passwordInput.value = '';
                    setTimeout(() => {
                        passwordError.style.display = 'none';
                    }, 3000);
                }
            }

            passwordSubmitBtn.addEventListener('click', checkPassword);
            passwordInput.addEventListener('keypress', function(event) {
                if (event.key === 'Enter') {
                    checkPassword();
                }
            });

            passwordInput.focus();
        }

        function setupModeToggle() {
            const singleModeBtn = document.getElementById('singleModeBtn');
            const bulkModeBtn = document.getElementById('bulkModeBtn');
            const singleSection = document.getElementById('singleSection');
            const bulkSection = document.getElementById('bulkSection');
            const results = document.getElementById('results');
            const bulkResults = document.getElementById('bulkResults');

            singleModeBtn.addEventListener('click', () => {
                singleModeBtn.classList.add('active');
                bulkModeBtn.classList.remove('active');
                singleSection.style.display = 'block';
                bulkSection.style.display = 'none';
                results.style.display = 'none';
                bulkResults.style.display = 'none';
                hideError(); 
            });

            bulkModeBtn.addEventListener('click', () => {
                bulkModeBtn.classList.add('active');
                singleModeBtn.classList.remove('active');
                singleSection.style.display = 'none';
                bulkSection.style.display = 'block';
                results.style.display = 'none';
                bulkResults.style.display = 'none';
                hideError(); 
            });
        }

        async function runBulkAnalysis() {
            const week = document.getElementById('bulkWeek').value;
            const routesPerGame = 30; // Hardcoded for bulk analysis
            const gameFlow = 3;      // Hardcoded to Neutral for bulk analysis

            showBulkLoading(true);
            hideBulkResults();
            hideError();
            bulkResults = [];

            if (!supabaseClient) {
                showError('Supabase client not initialized. Cannot perform bulk analysis. Please refresh the page.');
                showBulkLoading(false);
                return; 
            }

            try {
                console.log('Starting bulk analysis...');
                
                // Test call to ensure the client is functional and the key is accepted
                const { error: testError } = await supabaseClient
                    .from('player_cover_stats') 
                    .select('player_name')     
                    .limit(1);

                if (testError) {
                    console.error('Supabase initial query failed:', testError);
                    throw new Error(`Supabase connection failed: ${testError.message}. Double-check your API key and table permissions.`);
                }
                console.log('Supabase client is making requests successfully (initial test passed).');
                updateProgress(5, `Connection verified. Fetching matchups for ${MATCHUPS_SEASON}...`);

                // STEP 1: Get matchups based on filters (using MATCHUPS_SEASON for weekly_matchups)
                let matchupsQuery = supabaseClient
                    .from('weekly_matchups')
                    .select('*')
                    .eq('season', MATCHUPS_SEASON); 

                if (week) {
                    matchupsQuery = matchupsQuery.eq('week', parseInt(week));
                }

                console.log(`Fetching matchups for season ${MATCHUPS_SEASON}...`);
                const { data: matchups, error: matchupError } = await matchupsQuery;

                if (matchupError) {
                    console.error(`Error fetching weekly_matchups for ${MATCHUPS_SEASON}:`, matchupError);
                    throw new Error(`Error fetching weekly matchups: ${matchupError.message}. Make sure the table exists and has data for ${MATCHUPS_SEASON}.`);
                }

                // DEBUGGING POINT 1
                console.log('Fetched Matchups (Season 2025):', matchups);

                if (!matchups || matchups.length === 0) {
                    console.warn(`No matchups found for the selected criteria (Season ${MATCHUPS_SEASON}, Week ${week || 'All'}).`);
                    showError(`No matchups found for the selected criteria (Season ${MATCHUPS_SEASON}, Week ${week || 'All'}). Please adjust filters.`);
                    showBulkLoading(false);
                    return;
                }

                console.log(`Found ${matchups.length} matchups for Season ${MATCHUPS_SEASON}.`);
                updateProgress(10, `Found ${matchups.length} matchups. Getting team list from matchups...`);

                // STEP 2: Extract all teams that have games AND CONVERT TO ABBREVIATIONS
                const teamsWithGames = new Set();
                matchups.forEach(matchup => {
                    teamsWithGames.add(getTeamAbbreviation(matchup.home_team));
                    teamsWithGames.add(getTeamAbbreviation(matchup.away_team));
                });
                
                // DEBUGGING POINT 2 (updated)
                console.log(`Teams with games (from 2025 matchups, converted to abbreviations):`, Array.from(teamsWithGames));

                if (teamsWithGames.size === 0) {
                    console.warn('No teams found in 2025 matchups or unable to convert to abbreviations. Check matchup data and teamAbbreviationMap.');
                    showError('No teams identified from 2025 matchups. Ensure data exists in weekly_matchups table and team names can be abbreviated.');
                    showBulkLoading(false);
                    return;
                }

                updateProgress(15, `Found ${teamsWithGames.size} teams with games. Fetching players...`);

                // STEP 3: Get players ONLY from teams that have games in the matchups
                console.log(`Fetching top players from Season ${PLAYER_STATS_SEASON} for teams with games: ${Array.from(teamsWithGames).join(', ')}`);
                const { data: players, error: playerError } = await supabaseClient
                    .from('player_cover_stats')
                    .select('player_name, team, tprr_player')
                    .eq('season', PLAYER_STATS_SEASON)
                    .eq('coverage_type', 'Overall')
                    .in('team', Array.from(teamsWithGames)) // THIS NOW USES ABBREVIATIONS
                    .gte('tprr_player', 0.08) // Minimum target rate
                    .order('tprr_player', { ascending: false })
                    .limit(200); // Get more players to ensure good coverage

                if (playerError) {
                    console.error(`Error fetching player_cover_stats for ${PLAYER_STATS_SEASON}:`, playerError);
                    throw new Error(`Error fetching player data: ${playerError.message}. Make sure the table exists and has data for ${PLAYER_STATS_SEASON}.`);
                }

                // DEBUGGING POINT 3 (updated)
                console.log(`Fetched Players (Season 2024, filtered by 2025 teams):`, players);

                if (!players || players.length === 0) {
                    console.warn(`No players found for teams with games (Season ${PLAYER_STATS_SEASON}, Teams: ${Array.from(teamsWithGames).join(', ')}).`);
                    showError(`No players found for teams with games (Season ${PLAYER_STATS_SEASON}). Please check that player data exists for these teams and team names match abbreviations.`);
                    showBulkLoading(false);
                    return;
                }

                console.log(`Found ${players.length} players for Season ${PLAYER_STATS_SEASON} from teams with games.`);
                updateProgress(20, `Found ${players.length} players from teams with games. Creating matchup combinations...`);

                // STEP 4: Create player-matchup combinations
                const playerMatchupCombos = [];
                
                players.forEach(player => {
                    // Matchup team names are full names, player team is abbreviation
                    const playerMatchups = matchups.filter(matchup => 
                        getTeamAbbreviation(matchup.home_team) === player.team || getTeamAbbreviation(matchup.away_team) === player.team
                    );
                    
                    playerMatchups.forEach(matchup => {
                        const opponent = getTeamAbbreviation(matchup.home_team) === player.team ? getTeamAbbreviation(matchup.away_team) : getTeamAbbreviation(matchup.home_team);
                        playerMatchupCombos.push({
                            player: player,
                            matchup: matchup, // Keep original matchup data for display if needed
                            opponent: opponent // Opponent is now also an abbreviation
                        });
                    });
                });

                console.log(`Created ${playerMatchupCombos.length} player-matchup combinations.`);
                
                if (playerMatchupCombos.length === 0) {
                    showError('No valid player-matchup combinations found. This may indicate a mismatch between player team names and matchup team names after abbreviation.');
                    showBulkLoading(false);
                    return;
                }

                // Limit to top combinations for processing speed (prioritize highest TPRR players)
                const limitedCombos = playerMatchupCombos
                    .sort((a, b) => b.player.tprr_player - a.player.tprr_player)
                    .slice(0, 50);
                    
                updateProgress(25, `Processing top ${limitedCombos.length} player-matchup combinations...`);

                // STEP 5: Process each player-matchup combination
                let processedCount = 0;
                for (let i = 0; i < limitedCombos.length; i++) {
                    const combo = limitedCombos[i];
                    const progressPercent = 25 + ((i + 1) / limitedCombos.length) * 70; // 25% to 95%
                    updateProgress(progressPercent, `Analyzing ${combo.player.player_name} vs ${combo.opponent} (Week ${combo.matchup.week})...`);

                    try {
                        const result = await calculatePlayerProjection(
                            combo.player.player_name,
                            combo.opponent, // Opponent is already abbreviation
                            gameFlow,        
                            routesPerGame,   
                            5.5 // Default betting line
                        );

                        if (result) {
                            bulkResults.push({
                                ...result,
                                week: combo.matchup.week,
                                matchup: `${player.team} ${combo.matchup.home_team === combo.player.team ? 'vs' : '@'} ${combo.opponent}`
                            });
                            processedCount++;
                        }
                    } catch (error) {
                        console.warn(`Skipping projection for ${combo.player.player_name} vs ${combo.opponent} (Week ${combo.matchup.week}) due to error: ${error.message}`);
                    }
                }

                console.log(`Successfully processed ${processedCount} out of ${limitedCombos.length} combinations.`);
                updateProgress(95, 'Sorting and preparing results...');

                // Sort results by projected receptions (highest first)
                bulkResults.sort((a, b) => parseFloat(b.expectedReceptions) - parseFloat(a.expectedReceptions));

                // Limit to top 40 results for display
                bulkResults = bulkResults.slice(0, 40);

                updateProgress(100, 'Analysis complete!');
                
                if (bulkResults.length === 0) {
                    showError('Analysis completed but no valid projections were generated. This may indicate missing data for the selected teams/week.');
                } else {
                    displayBulkResults();
                }

            } catch (error) {
                console.error('Bulk analysis failed overall:', error);
                showError(error.message);
            } finally {
                showBulkLoading(false);
            }
        }

        async function calculatePlayerProjection(playerName, opponentTeam, gameFlow, routesPerGame, bettingLine) {
            // opponentTeam is already an abbreviation here
            try {
                // Get player's team and overall stats (using PLAYER_STATS_SEASON)
                const { data: playerData, error: playerError } = await supabaseClient
                    .from('player_cover_stats')
                    .select('team, tprr_player')
                    .eq('player_name', playerName)
                    .eq('season', PLAYER_STATS_SEASON) 
                    .eq('coverage_type', 'Overall')
                    .limit(1);

                if (playerError) {
                    console.error(`Error fetching player_cover_stats for ${playerName} (Season ${PLAYER_STATS_SEASON}):`, playerError);
                    throw new Error(`Player data error for ${playerName}: ${playerError.message}`);
                }

                if (!playerData || playerData.length === 0) {
                    console.warn(`Player "${playerName}" (Season ${PLAYER_STATS_SEASON}) not found or no overall stats. Using simple projection.`);
                    const result = calculateSimpleProjection(playerName, null, opponentTeam, 0.15, routesPerGame, gameFlow); 
                    return { ...result, bettingLine: bettingLine, playerTeam: 'N/A' };
                }

                const playerTeam = playerData[0].team; // This will be the abbreviation
                const targetShare = (playerData[0].tprr_player * 100).toFixed(1);

                // Get opponent's coverage frequencies (using PLAYER_STATS_SEASON for defensive data)
                // opponentTeam is abbreviation, which should match defensive_coverages team_name
                const { data: coverageData, error: coverageError } = await supabaseClient
                    .from('defensive_coverages')
                    .select('*')
                    .eq('team_name', opponentTeam)
                    .eq('season', PLAYER_STATS_SEASON) // Defensive data from PLAYER_STATS_SEASON (2024)
                    .limit(1);

                if (coverageError) {
                    console.error(`Error fetching defensive_coverages for ${opponentTeam} (Season ${PLAYER_STATS_SEASON}):`, coverageError);
                    throw new Error(`Defensive coverage data error for ${opponentTeam}: ${coverageError.message}`);
                }

                if (!coverageData || coverageData.length === 0) {
                    console.warn(`No defensive coverage data for ${opponentTeam} (Season ${PLAYER_STATS_SEASON}), using defaults for calculation.`);
                    const result = calculateSimpleProjection(playerName, playerTeam, opponentTeam, targetShare, routesPerGame, gameFlow);
                    return { ...result, bettingLine: bettingLine };
                }

                const coverage = coverageData[0];
                
                const coverageTypes = [
                    { name: 'Man Coverage', pct: coverage.man_pct },
                    { name: 'Cover 2', pct: coverage.cover_2_pct },
                    { name: 'Cover 3', pct: coverage.cover_3_pct },
                    { name: 'Cover 4', pct: coverage.cover_4_pct },
                    { name: 'Cover 6', pct: coverage.cover_6_pct }
                ];

                // Get player stats for ALL coverage types (using PLAYER_STATS_SEASON)
                const { data: playerStats, error: statsError } = await supabaseClient
                    .from('player_cover_stats')
                    .select('coverage_type, tprr_player, separation_score')
                    .eq('player_name', playerName)
                    .eq('team', playerTeam) // playerTeam is abbreviation
                    .eq('season', PLAYER_STATS_SEASON) 
                    .in('coverage_type', ['Man Coverage', 'Cover 2', 'Cover 3', 'Cover 4', 'Cover 6']);

                if (statsError) {
                    console.error(`Error fetching detailed player_cover_stats for ${playerName} (Season ${PLAYER_STATS_SEASON}):`, statsError);
                    throw new Error(`Player coverage stats error for ${playerName}: ${statsError.message}`);
                }

                if (!playerStats || playerStats.length === 0) {
                    console.warn(`No detailed coverage stats found for ${playerName} (Season ${PLAYER_STATS_SEASON}), using simple projection.`);
                    const result = calculateSimpleProjection(playerName, playerTeam, opponentTeam, targetShare, routesPerGame, gameFlow);
                    return { ...result, bettingLine: bettingLine };
                }

                // Calculate weighted TPRR and separation scores
                let weightedTPRR = 0;
                let weightedSeparation = 0;
                let totalWeight = 0;

                coverageTypes.forEach(coverage => {
                    if (coverage.pct > 0) {
                        const playerStat = playerStats.find(s => s.coverage_type === coverage.name);
                        if (playerStat) {
                            const weight = coverage.pct / 100;
                            weightedTPRR += (playerStat.tprr_player * 100) * weight;
                            weightedSeparation += (playerStat.separation_score || 0.2) * weight;
                            totalWeight += weight;
                        }
                    }
                });

                if (totalWeight === 0) {
                    console.warn(`No valid coverage data for ${playerName} from fetched stats to calculate weighted scores. Using simple projection.`);
                    const result = calculateSimpleProjection(playerName, playerTeam, opponentTeam, targetShare, routesPerGame, gameFlow);
                    return { ...result, bettingLine: bettingLine };
                }

                const stats = {
                    tprr_player: weightedTPRR / totalWeight,
                    separation_score: weightedSeparation / totalWeight
                };

                const mostFrequent = coverageTypes.filter(c => c.pct > 0).sort((a, b) => b.pct - a.pct)[0] || { name: 'Cover 3', pct: 30 };

                // Get defensive matchup stats (using PLAYER_STATS_SEASON)
                // opponentTeam is abbreviation, which should match defensive_matchups defensive_team_name
                const { data: defStats, error: defMatchupError } = await supabaseClient
                    .from('defensive_matchups')
                    .select('tprr_allowed, catch_rate_allowed')
                    .eq('defensive_team_name', opponentTeam)
                    .eq('season', PLAYER_STATS_SEASON) 
                    .eq('coverage_type', mostFrequent.name)
                    .limit(1);
                
                if (defMatchupError) {
                    console.error(`Error fetching defensive_matchups for ${opponentTeam} (Season ${PLAYER_STATS_SEASON}):`, defMatchupError);
                }

                const defMatchup = defStats && defStats[0] ? defStats[0] : { tprr_allowed: 0.185, catch_rate_allowed: 63 };
                if (!defStats || defStats.length === 0) {
                    console.warn(`No specific defensive matchup stats for ${opponentTeam} in ${mostFrequent.name} coverage (Season ${PLAYER_STATS_SEASON}). Using default.`);
                }

                const result = calculateReceptionScore(
                    stats.tprr_player,
                    stats.separation_score,
                    parseFloat(targetShare),
                    routesPerGame,
                    gameFlow,
                    mostFrequent.pct,
                    defMatchup.tprr_allowed * 100,
                    defMatchup.catch_rate_allowed
                );

                const projection = parseFloat(result.expectedReceptions);
                const edgeScore = projection - bettingLine;

                return {
                    playerName,
                    playerTeam,
                    opponentTeam,
                    targetShare,
                    tprr: stats.tprr_player.toFixed(1),
                    sepScore: stats.separation_score.toFixed(3),
                    expectedReceptions: result.expectedReceptions,
                    bettingLine: bettingLine, 
                    edgeScore: edgeScore 
                };

            } catch (error) {
                console.error(`Full projection calculation failed for ${playerName} vs ${opponentTeam}:`, error);
                throw error; 
            }
        }

        function calculateSimpleProjection(playerName, playerTeam, opponentTeam, targetShare, routesPerGame, gameFlow) {
            const gameScriptMultiplier = 0.85 + (gameFlow * 0.075);
            const effectiveTPRR = parseFloat(targetShare) / 100; 
            const baseProjection = routesPerGame * effectiveTPRR * 0.65 * gameScriptMultiplier; 
            
            return {
                playerName,
                playerTeam: playerTeam || 'N/A', 
                opponentTeam,
                targetShare: (effectiveTPRR * 100).toFixed(1),
                tprr: (effectiveTPRR * 100).toFixed(1),
                sepScore: "0.200", 
                expectedReceptions: baseProjection.toFixed(1),
                edgeScore: 0 
            };
        }

        function displayBulkResults() {
            const resultsCount = document.getElementById('resultsCount');
            const resultsList = document.getElementById('bulkResultsList');
            
            resultsCount.textContent = `Top ${bulkResults.length} players by projected receptions`; 
            
            if (bulkResults.length === 0) {
                resultsList.innerHTML = '<div class="loading">No players found matching criteria or no projections generated for this week.</div>';
                document.getElementById('bulkResults').style.display = 'block';
                return;
            }

            // You might want to enhance the 'matchup' display in bulk to show full team names
            // For example, if result.playerTeam and result.opponentTeam are abbreviations here,
            // you'd need a reverse mapping to display full names if desired.
            // For now, it will display abbreviations.
            resultsList.innerHTML = bulkResults.map((result, index) => `
                <div class="bulk-result-item">
                    <div class="result-header">
                        <div>
                            <div class="player-info">#${index + 1} ${result.playerName} (${result.playerTeam})</div>
                            <div class="matchup-info">Week ${result.week} - ${result.matchup}</div>
                        </div>
                        <div class="projection-score">
                            ${result.expectedReceptions} rec
                        </div>
                    </div>
                    <div class="result-details">
                        <div class="detail-item">
                            <div class="detail-label">Projection</div>
                            <div class="detail-value">${result.expectedReceptions}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Target Share</div>
                            <div class="detail-value">${result.targetShare}%</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">TPRR</div>
                            <div class="detail-value">${result.tprr}%</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Separation</div>
                            <div class="detail-value">${result.sepScore}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Opponent</div>
                            <div class="detail-value">${result.opponentTeam}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Week</div>
                            <div class="detail-value">${result.week}</div>
                        </div>
                    </div>
                </div>
            `).join('');

            document.getElementById('bulkResults').style.display = 'block';
        }

        function updateProgress(percentage, text) {
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            
            progressFill.style.width = percentage + '%';
            progressText.textContent = text;
        }

        function showBulkLoading(show) {
            document.getElementById('bulkProgress').style.display = show ? 'block' : 'none';
        }

        function hideBulkResults() {
            document.getElementById('bulkResults').style.display = 'none';
        }

        function exportResults() {
            if (bulkResults.length === 0) return;

            const csvContent = [
                ['Rank', 'Player', 'Team', 'Week', 'Matchup', 'Opponent', 'Projection', 'Target Share', 'TPRR', 'Separation'].join(','),
                ...bulkResults.map((result, index) => [
                    index + 1,
                    result.playerName,
                    result.playerTeam,
                    result.week,
                    result.matchup,
                    result.opponentTeam,
                    result.expectedReceptions,
                    result.targetShare + '%',
                    result.tprr + '%',
                    result.sepScore
                ].join(','))
            ].join('\n');

            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `nfl-top-projections-${new Date().toISOString().split('T')[0]}.csv`;
            a.click();
            window.URL.revokeObjectURL(url);
        }

        function normalizeTeamName(input) {
            // This function is primarily used by the single player autocomplete and input.
            // It tries to convert various inputs to a standardized full name.
            const teamMapping = {
                'ARI': 'Arizona Cardinals', 'ATL': 'Atlanta Falcons', 'BAL': 'Baltimore Ravens',
                'BUF': 'Buffalo Bills', 'CAR': 'Carolina Panthers', 'CHI': 'Chicago Bears',
                'CIN': 'Cincinnati Bengals', 'CLE': 'Cleveland Browns', 'DAL': 'Dallas Cowboys',
                'DEN': 'Denver Broncos', 'DET': 'Detroit Lions', 'GB': 'Green Bay Packers',
                'HOU': 'Houston Texans', 'IND': 'Indianapolis Colts', 'JAX': 'Jacksonville Jaguars',
                'KC': 'Kansas City Chiefs', 'LV': 'Las Vegas Raiders', 'LAC': 'Los Angeles Chargers',
                'LAR': 'Los Angeles Rams', 'MIA': 'Miami Dolphins', 'MIN': 'Minnesota Vikings',
                'NE': 'New England Patriots', 'NO': 'New Orleans Saints', 'NYG': 'New York Giants',
                'NYJ': 'New York Jets', 'PHI': 'Philadelphia Eagles', 'PIT': 'Pittsburgh Steelers',
                'SF': 'San Francisco 49ers', 'SEA': 'Seattle Seahawks', 'TB': 'Tampa Bay Buccaneers',
                'TEN': 'Tennessee Titans', 'WAS': 'Washington Commanders'
            };
            
            const upperInput = input.trim().toUpperCase();
            // Check if input is an abbreviation
            for (const fullName in teamMapping) {
                if (teamMapping[fullName] === upperInput) { // Check if abbreviation matches
                    return fullName; // Return the full name if input was an abbreviation
                }
            }
            if (teamMapping[upperInput]) { // This case handles if someone types "ARI" directly
                return teamMapping[upperInput];
            }
            
            for (const fullName of Object.values(teamMapping)) { // Check if input is a full name
                if (input.trim().toLowerCase() === fullName.toLowerCase()) {
                    return fullName;
                }
            }
            
            return input.trim(); // Return original if no match
        }

        async function calculateProjection() {
            const playerName = document.getElementById('playerName').value.trim();
            const opponentTeamFull = normalizeTeamName(document.getElementById('opponentTeam').value); // Get full name
            const opponentTeamAbbr = getTeamAbbreviation(opponentTeamFull); // Convert to abbr for API calls
            const gameFlow = parseInt(document.getElementById('gameFlow').value);
            const routesPerGame = parseInt(document.getElementById('routesPerGame').value);
            const bettingLine = parseFloat(document.getElementById('bettingLine').value);

            if (!playerName || !opponentTeamFull || isNaN(routesPerGame) || isNaN(bettingLine)) { 
                showError('Please fill in all fields with valid numbers where required.');
                return;
            }
            
            if (!supabaseClient) {
                showError('Supabase client not initialized. Cannot calculate projection. Please refresh the page.');
                showLoading(false);
                return; 
            }

            showLoading(true);
            hideError();
            hideResults();

            try {
                // 1. Get player's team and overall stats (using PLAYER_STATS_SEASON)
                const { data: playerData, error: playerError } = await supabaseClient
                    .from('player_cover_stats')
                    .select('team, tprr_player')
                    .eq('player_name', playerName)
                    .eq('season', PLAYER_STATS_SEASON) 
                    .eq('coverage_type', 'Overall')
                    .limit(1);

                if (playerError) {
                    console.error(`Error fetching player_cover_stats for ${playerName} (Season ${PLAYER_STATS_SEASON}):`, playerError);
                    throw new Error(`Player "${playerName}" data error: ${playerError.message}`);
                }

                if (!playerData || playerData.length === 0) {
                    console.warn(`Player "${playerName}" (Season ${PLAYER_STATS_SEASON}) not found or no overall stats. Using simple projection.`);
                    const result = calculateSimpleProjection(playerName, null, opponentTeamAbbr, 0.15, routesPerGame, gameFlow); 
                    displayResults({
                        playerName,
                        playerTeam: 'N/A',
                        opponentTeam: opponentTeamFull, // Display full name
                        coverageType: "Simple Projection (Player data missing)", 
                        coverageFreq: 100,
                        coverageBreakdown: [],
                        targetShare: result.targetShare,
                        tprr: result.tprr,
                        sepScore: result.sepScore,
                        expectedReceptions: result.expectedReceptions,
                        receptionScore: result.edgeScore,
                        bettingLine: bettingLine
                    });
                    return; 
                }

                const playerTeam = playerData[0].team; // This will be the abbreviation
                const targetShare = (playerData[0].tprr_player * 100).toFixed(1);

                // 2. Get opponent's coverage frequencies (using PLAYER_STATS_SEASON)
                // Use the abbreviation for the database query
                const { data: coverageData, error: coverageError } = await supabaseClient
                    .from('defensive_coverages')
                    .select('*')
                    .eq('team_name', opponentTeamAbbr) // Use abbreviation here
                    .eq('season', PLAYER_STATS_SEASON) 
                    .limit(1);

                if (coverageError) {
                    console.error(`Error fetching defensive_coverages for ${opponentTeamAbbr} (Season ${PLAYER_STATS_SEASON}):`, coverageError);
                    throw new Error(`Defensive coverage data error for ${opponentTeamFull}: ${coverageError.message}`);
                }

                if (!coverageData || coverageData.length === 0) {
                    console.warn(`No defensive coverage data for ${opponentTeamAbbr} (Season ${PLAYER_STATS_SEASON}), using defaults for calculation.`);
                    const result = calculateSimpleProjection(playerName, playerTeam, opponentTeamAbbr, targetShare, routesPerGame, gameFlow);
                    displayResults({
                        playerName,
                        playerTeam,
                        opponentTeam: opponentTeamFull, // Display full name
                        coverageType: "Simple Projection (Defensive coverage missing)", 
                        coverageFreq: 100,
                        coverageBreakdown: [],
                        targetShare: result.targetShare,
                        tprr: result.tprr,
                        sepScore: result.sepScore,
                        expectedReceptions: result.expectedReceptions,
                        receptionScore: result.edgeScore,
                        bettingLine: bettingLine
                    });
                    return; 
                }

                const coverage = coverageData[0];
                
                const coverageTypes = [
                    { name: 'Man Coverage', pct: coverage.man_pct },
                    { name: 'Cover 2', pct: coverage.cover_2_pct },
                    { name: 'Cover 3', pct: coverage.cover_3_pct },
                    { name: 'Cover 4', pct: coverage.cover_4_pct },
                    { name: 'Cover 6', pct: coverage.cover_6_pct }
                ];

                // 3. Get player stats for ALL coverage types (using PLAYER_STATS_SEASON)
                const { data: playerStats, error: statsError } = await supabaseClient
                    .from('player_cover_stats')
                    .select('coverage_type, tprr_player, separation_score')
                    .eq('player_name', playerName)
                    .eq('team', playerTeam) // playerTeam is abbreviation
                    .eq('season', PLAYER_STATS_SEASON) 
                    .in('coverage_type', ['Man Coverage', 'Cover 2', 'Cover 3', 'Cover 4', 'Cover 6']);

                if (statsError) {
                    console.error(`Error fetching detailed player_cover_stats for ${playerName} (Season ${PLAYER_STATS_SEASON}):`, statsError);
                    throw new Error(`Player coverage stats error for ${playerName}: ${statsError.message}`);
                }

                if (!playerStats || playerStats.length === 0) {
                    console.warn(`No detailed coverage stats found for ${playerName} (Season ${PLAYER_STATS_SEASON}), using simple projection.`);
                    const result = calculateSimpleProjection(playerName, playerTeam, opponentTeamAbbr, targetShare, routesPerGame, gameFlow);
                    displayResults({
                        playerName,
                        playerTeam,
                        opponentTeam: opponentTeamFull, // Display full name
                        coverageType: "Simple Projection (Player coverage stats missing)",
                        coverageFreq: 100,
                        coverageBreakdown: [],
                        targetShare: result.targetShare,
                        tprr: result.tprr,
                        sepScore: result.sepScore,
                        expectedReceptions: result.expectedReceptions,
                        receptionScore: result.edgeScore,
                        bettingLine: bettingLine
                    });
                    return; 
                }

                // Calculate weighted TPRR and separation scores
                let weightedTPRR = 0;
                let weightedSeparation = 0;
                let totalWeight = 0;
                let coverageBreakdown = [];

                coverageTypes.forEach(coverage => {
                    if (coverage.pct > 0) {
                        const playerStat = playerStats.find(s => s.coverage_type === coverage.name);
                        if (playerStat) {
                            const weight = coverage.pct / 100;
                            weightedTPRR += (playerStat.tprr_player * 100) * weight;
                            weightedSeparation += (playerStat.separation_score || 0.2) * weight;
                            totalWeight += weight;
                            
                            coverageBreakdown.push({
                                name: coverage.name,
                                frequency: coverage.pct,
                                playerTPRR: (playerStat.tprr_player * 100).toFixed(1)
                            });
                        }
                    }
                });

                if (totalWeight === 0) {
                    console.warn(`No valid coverage data for ${playerName} from fetched stats to calculate weighted scores. Using simple projection.`);
                    const result = calculateSimpleProjection(playerName, playerTeam, opponentTeamAbbr, targetShare, routesPerGame, gameFlow);
                    displayResults({
                        playerName,
                        playerTeam,
                        opponentTeam: opponentTeamFull, // Display full name
                        coverageType: "Simple Projection (Weighted calc failed)",
                        coverageFreq: 100,
                        coverageBreakdown: [],
                        targetShare: result.targetShare,
                        tprr: result.tprr,
                        sepScore: result.sepScore,
                        expectedReceptions: result.expectedReceptions,
                        receptionScore: result.edgeScore,
                        bettingLine: bettingLine
                    });
                    return; 
                }

                const stats = {
                    tprr_player: weightedTPRR / totalWeight,
                    separation_score: weightedSeparation / totalWeight
                };

                const mostFrequent = coverageTypes.filter(c => c.pct > 0).sort((a, b) => b.pct - a.pct)[0] || { name: 'Cover 3', pct: 30 };

                // 4. Get defensive matchup stats (using PLAYER_STATS_SEASON)
                // Use the abbreviation for the database query
                const { data: defStats, error: defMatchupError } = await supabaseClient
                    .from('defensive_matchups')
                    .select('tprr_allowed, catch_rate_allowed')
                    .eq('defensive_team_name', opponentTeamAbbr) // Use abbreviation here
                    .eq('season', PLAYER_STATS_SEASON) 
                    .eq('coverage_type', mostFrequent.name)
                    .limit(1);
                
                if (defMatchupError) {
                    console.error(`Error fetching defensive_matchups for ${opponentTeamAbbr} (Season ${PLAYER_STATS_SEASON}):`, defMatchupError);
                }

                const defMatchup = defStats && defStats[0] ? defStats[0] : { tprr_allowed: 0.185, catch_rate_allowed: 63 };
                if (!defStats || defStats.length === 0) {
                    console.warn(`No specific defensive matchup stats for ${opponentTeamAbbr} in ${mostFrequent.name} coverage (Season ${PLAYER_STATS_SEASON}). Using default.`);
                }

                // 5. Calculate score using weighted stats
                const result = calculateReceptionScore(
                    stats.tprr_player,
                    stats.separation_score,
                    parseFloat(targetShare),
                    routesPerGame,
                    gameFlow,
                    mostFrequent.pct,
                    defMatchup.tprr_allowed * 100,
                    defMatchup.catch_rate_allowed
                );

                const projection = parseFloat(result.expectedReceptions);
                const edgeDifference = projection - bettingLine; // Calculate difference for display
                const edgeScore = (edgeDifference >= 0 ? '+' : '') + edgeDifference.toFixed(1);

                displayResults({
                    playerName,
                    playerTeam,
                    opponentTeam: opponentTeamFull, // Display full name
                    coverageType: "Weighted Analysis",
                    coverageFreq: 100,
                    coverageBreakdown,
                    targetShare,
                    tprr: stats.tprr_player.toFixed(1),
                    sepScore: stats.separation_score.toFixed(3),
                    expectedReceptions: result.expectedReceptions,
                    receptionScore: result.finalScore, // This is the overall model score
                    bettingLine: bettingLine,
                    edgeScore: edgeScore // Pass edgeScore explicitly for display
                });

            } catch (error) {
                console.error('Projection calculation failed:', error);
                showError(error.message);
            } finally {
                showLoading(false);
            }
        }

        function calculateReceptionScore(weightedTPRR, weightedSeparation, targetShare, routesPerGame, gameFlow, primaryCoverageFreq, defTPRR, defCatchRate) {
            // === ADVANCED STATISTICAL MODEL ===
            
            // 1. EFFICIENCY COMPONENT (40% weight)
            const tprrZScore = (weightedTPRR - 18.5) / 5.0;
            const efficiencyScore = Math.max(0, 50 + (tprrZScore * 15));
            
            // 2. VOLUME COMPONENT (30% weight)
            const totalOpportunity = (targetShare / 100) * routesPerGame;
            const volumeScore = Math.min(totalOpportunity * 2.5, 100);
            
            // 3. SEPARATION COMPONENT (15% weight) 
            const separationZScore = (weightedSeparation - 0.20) / 0.05;
            const separationScore = Math.max(0, 50 + (separationZScore * 12));
            
            // 4. DEFENSIVE MATCHUP COMPONENT (15% weight)
            const defTPRRZScore = (defTPRR - 18.5) / 3.0;
            const defCatchZScore = (defCatchRate - 63.0) / 5.0;
            const matchupScore = 50 + (defTPRRZScore * 10) + (defCatchZScore * 8);
            
            // 5. GAME SCRIPT MULTIPLIER
            const gameScriptMultiplier = 0.85 + (gameFlow * 0.075);
            
            // === COMBINE COMPONENTS ===
            const baseScore = (efficiencyScore * 0.40) + 
                            (volumeScore * 0.30) + 
                            (separationScore * 0.15) + 
                            (matchupScore * 0.15);
            
            const finalScore = Math.min(baseScore * gameScriptMultiplier, 100);
            
            // === EXPECTED RECEPTIONS CALCULATION ===
            const baseReceptions = routesPerGame * (weightedTPRR / 100) * (defCatchRate / 100) * gameScriptMultiplier;
            
            let confidenceFactor = 1.0;
            if (finalScore >= 80) confidenceFactor = 1.15;
            else if (finalScore >= 65) confidenceFactor = 1.05;
            else if (finalScore >= 35) confidenceFactor = 1.0;
            else if (finalScore >= 20) confidenceFactor = 0.95;
            else confidenceFactor = 0.85;
            
            const expectedReceptions = (baseReceptions * confidenceFactor).toFixed(1);
            
            return {
                finalScore: finalScore.toFixed(1),
                expectedReceptions
            };
        }

        function displayResults(data) {
            let coverageInfoHtml = `<h4>Coverage Analysis</h4>`;
            if (data.coverageBreakdown && data.coverageBreakdown.length > 0) {
                coverageInfoHtml += `<p>Defensive coverages faced by ${data.opponentTeam}:</p><ul>`;
                data.coverageBreakdown.forEach(item => {
                    coverageInfoHtml += `<li>${item.name}: ${item.frequency}% (Player TPRR: ${item.playerTPRR}%)</li>`;
                });
                coverageInfoHtml += `</ul>`;
            } else {
                coverageInfoHtml += `<p>${data.coverageType} used due to missing detailed data for player or defense.</p>`;
            }
            document.getElementById('coverageInfo').innerHTML = coverageInfoHtml;
            
            const projection = parseFloat(data.expectedReceptions);
            const line = data.bettingLine;
            const edgeDifference = projection - line;
            const edgeScore = (edgeDifference >= 0 ? '+' : '') + edgeDifference.toFixed(1);
            
            document.getElementById('playerDisplay').textContent = `${data.playerName} (${data.playerTeam})`;
            document.getElementById('defenseDisplay').textContent = data.opponentTeam; // Displays full name
            document.getElementById('targetShare').textContent = `${data.targetShare}%`;
            document.getElementById('tprrDisplay').textContent = `${data.tprr}%`;
            document.getElementById('sepScoreDisplay').textContent = data.sepScore;
            document.getElementById('expectedReceptions').textContent = data.expectedReceptions;
            document.getElementById('finalScore').textContent = edgeScore; // Displaying calculated edge score

            let interpretation = '';
            let interpretClass = '';

            if (edgeDifference >= 1.5) {
                interpretation = 'GOOD EDGE - Significant positive value';
                interpretClass = 'score-high';
            } else if (edgeDifference >= 0.5) { 
                interpretation = 'MODERATE EDGE - Positive value, consider';
                interpretClass = 'score-medium';
            } else if (edgeDifference >= 0) {
                interpretation = 'SLIGHT EDGE - Proceed with caution';
                interpretClass = 'score-medium';
            }
            else if (edgeDifference > -0.5) { 
                interpretation = 'NEUTRAL EDGE - Minimal difference';
                interpretClass = 'score-medium';
            }
            else {
                interpretation = 'POOR EDGE - Negative value, avoid bet';
                interpretClass = 'score-low';
            }

            const interpretDiv = document.getElementById('interpretation');
            interpretDiv.textContent = interpretation;
            interpretDiv.className = 'score-interpretation ' + interpretClass;

            document.getElementById('results').style.display = 'block';
        }

        function showLoading(show) {
            document.getElementById('loadingDiv').style.display = show ? 'block' : 'none';
        }

        function showError(message) {
            const errorDiv = document.getElementById('errorDiv');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        function hideError() {
            document.getElementById('errorDiv').style.display = 'none';
        }

        function hideResults() {
            document.getElementById('results').style.display = 'none';
        }

        // Autocomplete functionality
        async function setupAutocomplete() {
            await loadPlayerNames(); 
            setupPlayerAutocomplete();
            setupTeamAutocomplete();
        }

        async function loadPlayerNames() {
            if (!supabaseClient) {
                console.warn('Supabase client not initialized when attempting to load player names for autocomplete.');
                return; 
            }
            try {
                const { data, error } = await supabaseClient
                    .from('player_cover_stats')
                    .select('player_name')
                    .eq('season', PLAYER_STATS_SEASON) 
                    .eq('coverage_type', 'Overall');
                
                if (data) {
                    const uniqueNames = [...new Set(data.map(player => player.player_name))];
                    playerList = uniqueNames.sort();
                    console.log('Player names loaded for autocomplete.');
                }
                if (error) {
                    console.error('Error loading player names for autocomplete:', error);
                }
            } catch (error) {
                console.error('Error loading player names (catch block):', error);
            }
        }

        function setupPlayerAutocomplete() {
            const input = document.getElementById('playerName');
            const suggestions = document.getElementById('playerSuggestions');
            
            input.addEventListener('input', function() {
                const value = this.value.toLowerCase();
                selectedIndex = -1;
                
                if (value.length < 2) {
                    suggestions.style.display = 'none';
                    return;
                }
                
                const filtered = playerList.filter(player => 
                    player.toLowerCase().includes(value)
                ).slice(0, 8);
                
                if (filtered.length > 0) {
                    suggestions.innerHTML = filtered.map(player => 
                        `<div class="autocomplete-suggestion">${player}</div>`
                    ).join('');
                    suggestions.style.display = 'block';
                    
                    suggestions.querySelectorAll('.autocomplete-suggestion').forEach((item, index) => {
                        item.addEventListener('click', () => {
                            input.value = item.textContent;
                            suggestions.style.display = 'none';
                        });
                    });
                } else {
                    suggestions.style.display = 'none';
                }
            });
            
            input.addEventListener('keydown', function(e) {
                const items = suggestions.querySelectorAll('.autocomplete-suggestion');
                
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    selectedIndex = Math.min(selectedIndex + 1, items.length - 1);
                    updateSelection(items);
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    selectedIndex = Math.max(selectedIndex - 1, -1);
                    updateSelection(items);
                } else if (e.key === 'Enter' && selectedIndex >= 0) {
                    e.preventDefault();
                    input.value = items[selectedIndex].textContent;
                    suggestions.style.display = 'none';
                } else if (e.key === 'Escape') {
                    suggestions.style.display = 'none';
                }
            });
            
            document.addEventListener('click', function(e) {
                if (!input.contains(e.target) && !suggestions.contains(e.target)) {
                    suggestions.style.display = 'none';
                }
            });
        }

        function setupTeamAutocomplete() {
            const input = document.getElementById('opponentTeam');
            const suggestions = document.getElementById('teamSuggestions');
            
            const teams = [
                'Arizona Cardinals', 'Atlanta Falcons', 'Baltimore Ravens', 'Buffalo Bills',
                'Carolina Panthers', 'Chicago Bears', 'Cincinnati Bengals', 'Cleveland Browns',
                'Dallas Cowboys', 'Denver Broncos', 'Detroit Lions', 'Green Bay Packers',
                'Houston Texans', 'Indianapolis Colts', 'Jacksonville Jaguars', 'Kansas City Chiefs',
                'Las Vegas Raiders', 'Los Angeles Chargers', 'Los Angeles Rams', 'Miami Dolphins',
                'Minnesota Vikings', 'New England Patriots', 'New Orleans Saints', 'New York Giants',
                'New York Jets', 'Philadelphia Eagles', 'Pittsburgh Steelers', 'San Francisco 49ers',
                'Seattle Seahawks', 'Tampa Bay Buccaneers', 'Tennessee Titans', 'Washington Commanders'
            ];
            
            input.addEventListener('input', function() {
                const value = this.value.toLowerCase();
                selectedIndex = -1;
                
                if (value.length < 1) {
                    suggestions.style.display = 'none';
                    return;
                }
                
                const filtered = teams.filter(team => 
                    team.toLowerCase().includes(value) || 
                    teamAbbreviationMap[team] && teamAbbreviationMap[team].toLowerCase().includes(value) // Check for abbr match
                ).slice(0, 8);
                
                if (filtered.length > 0) {
                    suggestions.innerHTML = filtered.map(team => 
                        `<div class="autocomplete-suggestion">${team}</div>`
                    ).join('');
                    suggestions.style.display = 'block';
                    
                    suggestions.querySelectorAll('.autocomplete-suggestion').forEach((item, index) => {
                        item.addEventListener('click', () => {
                            input.value = item.textContent;
                            suggestions.style.display = 'none';
                        });
                    });
                } else {
                    suggestions.style.display = 'none';
                }
            });
            
            input.addEventListener('keydown', function(e) {
                const items = suggestions.querySelectorAll('.autocomplete-suggestion');
                
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    selectedIndex = Math.min(selectedIndex + 1, items.length - 1);
                    updateSelection(items);
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    selectedIndex = Math.max(selectedIndex - 1, -1);
                    updateSelection(items);
                } else if (e.key === 'Enter' && selectedIndex >= 0) {
                    e.preventDefault();
                    input.value = items[selectedIndex].textContent;
                    suggestions.style.display = 'none';
                } else if (e.key === 'Escape') {
                    suggestions.style.display = 'none';
                }
            });
            
            document.addEventListener('click', function(e) {
                if (!input.contains(e.target) && !suggestions.contains(e.target)) {
                    suggestions.style.display = 'none';
                }
            });
        }

        function updateSelection(items) {
            items.forEach((item, index) => {
                if (index === selectedIndex) {
                    item.classList.add('selected');
                } else {
                    item.classList.remove('selected');
                }
            });
        }
    </script>
</body>
</html>
